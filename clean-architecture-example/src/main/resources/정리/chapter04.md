# 유스케이스 구현하기

## 유스케이스 둘러보기

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

* 유스케이스는 인커밍 어댑터로부터 입력을 받는다. 이 단계를 왜 `입력 유효성 검증`으로 부르지 않는지 의아할 수도 있다.
* 유스케이스 코드가 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안된다. 그러나 유스케이스는 **비즈니스 규칙(business rule)**을
 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.
* 비즈니스 규칙을 총족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.
* 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다.
* 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.
* 마지막 단계는 아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환하는 것이다.

## 입력 유효성 검증

* 애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터
 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.
* 입력 모델에서 유효성 검증하도록 하자. 

## 생성자의 힘

* 파라미터가 많다면 빌더 패턴을 이용해 편하게 생성 할 수 있다. 하지만 빌더 패턴은 컴파일러가 유효하지 않은 상태의
 불변 객체를 만들려는 시도에 대해 경고를 해주지 못한다.
* 물론 런타임에 유효성 검증 로직에서 예외를 던지겠지만 그래도 컴파일러가 발견하는게 제일 좋은 것이다.
* 긴 파라미터 리스트도 충분히 깔끔하게 포매팅할 수 있고 훌륭한 IDE들은 파라미텀여 힌트도 준다.

## 유스케이스마다 다른 입력 모델

* 각기 다른 유스케이스에 동일한 입력 모델을 사용하고 싶은 생각이 들 때가 있다. 보통 생성, 수정이 그러하다.
  * 생성, 수정은 다른 유효성 검증 로직이 필요하다.
* 결론 유스케이스에 따라 모델을 각각 만들어야 한다.
* 각 유스케이스 전용 입력 모델은 유스케이스를 휠씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한
 부수효과가 발생하지 않게 한다.

## 비즈니스 규칙 검증하기

* 입력 유효성 검증은 유스케이스 로직의 일부가 아닌 반면, 비즈니스 규칙 검증은 분명히 유스케이스 로직의 일부다.
* 비즈니스 규칙은 애플리케이션의 핵심이기에 적절하게 잘 다뤄야 한다. 
* 입력 유효성을 검증하는 것은 **구문상의(syntactical)** 유효성을 검증하는 것이라고도 할 수 있다.
  * `송금되는 금액은 0보다 커야 한다`라는 규칙은 모델에 접근하지 않고도 검증될 수 있으므로 입력 유효성 검증
* 반면 비즈니스 규칙은 유스케이스의 맥락 속에서 **의미적인(semantical)** 유효성을 검증하는 일이라고 할 수 있다.
  * `출금 계좌는 초과 출금되어서는 안 된다`라는 규칙은 모델의 현재 상태에 접근해야 하기 때문에 비즈니스 규칙이다.
  * 비즈니스 규칙은 도메인 엔티티 안에 넣는 것이 좋다.
  * 만약 도메인 엔티티에서 비즈니스 규칙을 검증하기 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.

## 풍부한 도메인 모델 vs 빈약한 도메인 모델

### 풍부한 도메인 모델

* 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다.
* 엔티티들은 상태를 변경하는 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용한다.
* 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.

### 빈약한 도메인 모델

* 엔티티 자체가 굉장히 얇다. 일반적으로 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 getter, setter
 메서드만 포함하고 어떤 도메인 로직도 가지고 있지 않다.
* 이 말인 즉슨, 도메인 로직이 유스케이스 클래스에 구현돼 있다는 것이다.
* 비즈니스 규칙을 검증하고, 엔티티의 상태를 바꾸고, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 역시 유스케이스 클래스에 있다.

## 유스케이스마다 다른 출력 모델

* 입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋다. 출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다.
* 유스케이스들 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다.
* 한 유스케이스에서 출력 모델에 새로운 필드가 필요해지면 이 값과 관련이 없는 다른 유스케이스에서도 이 필드를 처리해야 한다.
* 공유 모델은 장기적으로 봤을 때 갖가지 이유로 점점 커지게 돼 있다. 단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것은
 유스케이스의 결합을 제거하는 데 도움이 된다.

## 읽기 전용 유스케이스는 어떨까?

* 일기 전용 유스케이스는 전체 프로젝트의 맥락에서 다른 유스케이스와 비슷한 방식으로 구현해야 한다.
* 하지만 애플리케이션 코어의 관점에서 이 작업은 간단한 데이터 쿼리다.
* 그렇기 때문에 프로젝트 맥락에서 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해 쿼리로 구현할 수 있다.
* 쿼리를 위한 인커밍 전용 포트를 만들고 이를 `쿼리 서비스(query service)`에 구현하는 것이다.
 쿼리 서비스는 유스케이스 서비스와 동일한 방식으로 동작한다. 인커밍 포트를 구현하고, 데이터베이스로부터 실제로 데이터를 로드하기 위해
 아웃고잉 포트를 호출한다.
* 이처럼 읽기 전용 쿼리는 쓰기가 가능한 유스케이스(또는 커맨드)와 코드 상에서 명확하게 구분된다.
* 이런 방식은 **CQS나 CQRS** 같은 개념과 아주 잘 맞는다.
