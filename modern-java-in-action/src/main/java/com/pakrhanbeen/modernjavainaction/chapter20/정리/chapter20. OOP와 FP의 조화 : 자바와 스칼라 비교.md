# OOP와 FP의 조화 : 자바와 스칼라 비교

## 스칼라 소개

* 스칼라는 객체지향과 함수형 프로그래밍을 혼합한 언어다.
* 스칼라는 복잡한 형식 시스템, 형식 추론, 패턴 매칭, 도메인 전용 언어를 단순하게 정의할 수 있는 구조 등을 제공한다.
* 스칼라 코드에서는 모든 자바 라이브러리를 사용할 수 있다.
* 자바와 마찬가지로 스칼라는 컬렉션을 ㅎ마수형으로 처리하는 개념(스트림과 비슷한 연산), 일급 함수, 디폴트 메서드 등을 제공한다.

>보통 스칼라의 비재귀 메서드에서는 반환형식을 추론할 수 있으므로 명시적으로 반환형식을 정의 하지 않아도 된다.

* 스칼라는 모든 것이 객체다. 자바와 달리 스칼라에는 기본형이 없다.
* 스칼라는 자바보다 완전한 객체지향 언어다.

### 자료구조

#### 컬렉션

* **Map**
  * `val authorsToAge = Map("Raoul" -> 23, "Mario" -> 40, "Alan" -> 53)`
  * `val`은 변수가 읽기 전용, 즉 변수에 값을 할당할 수 없음을 의미한다(자바의 `final`과 같다). `var`라는 키워드는 읽고 쓸 수 있는 변수를 가르킨다.
* **List, Set**
  * `val authors = List("Raoul", "Mario", "Alan")`
  * `val numbers = Set(1, 1, 2, 3, 5, 8)`
  * `authors` 변수는 세 개의 요소, `numbers` 변수는 다섯 개의 요소를 포함한다.


* 지금까지 만든 컬렉션은 기본적으로 **불변**이다. 즉, 일단 컬렉션을 만들면 변경할 수 없다.
* 스칼라는 불변 컬렉션을 갱신할 때 새로운 컬렉션을 만드는 방법으로 자료 구조를 갱신한다.
* 스칼라에서는 불변 컬렉션만 사용하도록 강제하는 것은 아니며 단지 불변성을 쉽게 적용할 수 있도록 도와주는 것임을 기억하자.
  * `sacla.collection.mutable`에서는 가변 버전의 컬렉션을 제공한다.

#### 튜블

* 특정 값을 그룹하는 튜플이라는 기능이 스칼라에는 지원한다. (자바는 지원하지 않는다)
```
val raoul = ("Raoul", "+ 44 8888898")
val alan = ("Alan", "+ 44 9999999")

println(raoul._1)  // Raoul
println(alan._2)  // + 44 9999999
```

#### 스트림

* 스칼라에서도 스트림이라는 게으르게 평가되는 자료구조를 제공한다. 스칼라의 스트림은 자바의 스트림보다 다양한 기능을 제공한다.
* 스칼라의 스트림은 이전 요소가 접근할 수 있도록 기존 계산값을 기억한다. 또한 인덱스를 제공하므로 리스트처럼 인덱스로 스트림의 요소에 
 접근할 수 있다.
* 이러한 기능이 추가되면서 스칼라의 스트림은 자바의 스트림에 비해 메모리 효율성이 조금 떨어진다.

#### 옵션

* 자바의 `Optional`과 같은 기능을 하는 `Option`을 제공한다.

## 함수

* 스칼라의 함수는 어떤 작업을 수행하는 일련의 명령어 그룹이다.
* 스칼라의 함수는 **일급값**이다. 즉, `Integer, String`처럼 함수를 인수로 전달하거나, 결과로 반환하거나, 변수에 저장할 수 있다.
```
def isJavaMentioned(tweet: String) : Boolen = tweet.contains("Java")
def isShortTweet(tweet: String) : Boolean = tweet.lenght < 20
```

### 익명 함수

* 스칼라도 **익명 함수**의 개념을 지원한다.
```
val isLongTweet : String => Boolean = (tweet : String) => tweet.length() > 60
```

### 클로저

* **클로저**란 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가리킨다.
* 하지만 자바의 람다 표현식에는 람다가 정의된 메서드의 지역 변수를 고칠 수 없다는 제약이 있다. 이들 변수는 암시적으로 final로 취급된다.
* 즉, **람다는 변수가 아닌 값을 닫는다**는 사실을 기억하자.
* 스칼라의 익명 함수는 값이 아니라 변수를 캡처할 수 있다.
```
def main(args: Array[String]) {
	var count = 0
	val inc = () => count+=1
	inc()                     // count를 캡처하고 증가시키는 클로저
	println(count)
	inc()
	println(count)
}
```
* 자바로 구현한 코드는 `count`가 암시적으로 `final`이 되므로 컴파일 에러가 발생한다.
* 프로그램을 쉽게 유지보수하고 병렬화할 수 있도록 변화를 피하기 위해서는 꼭 필요할 때만 클로저 기능을 사용하는 것이 바람직하다.

## 커링

* x, y라는 두 인수를 가진 f라는 함수가 있을 때 이는 하나의 인수를 받는 g라는 함수 그리고 g라는 함수는 다시 나머지 인수를 받는 함수로 반환되는 사오항으로 볼 수 있다는 것이다.
* 스칼라는 이 과정을 자동으로 처리하는 특수 문법을 제공한다.
```
def multiplyCurry(x: Int)(y: Int) = x * y
val r1 = multiplyCurry(2)(10) // result = 20

val multiplyByTwo : Int => Int = multiplyCurry(2) // 부분 적용된 함수라 부른다.
val r2 = multiplyByTwo(10) // result = 20
```

* 자바와 달리 스칼라에서는 커리된 함수를 직접 제공할 필요가 없다.
* 스칼라에서는 함수가 여러 커리된 인수 리스트를 포함하고 있음을 가리키는 함수 정의 문법을 제공하기 때문이다.

## 클래스

* 스칼라는 완전한 객체지향 언어이므로 클래스를 만들고 객체로 인스턴스화할 수 있다.
```
class Hello {
  def sayThankYou() {
    println("Thanks for reading our book")
  }
}
val h = new Hello()
h.sayThankYou()
```

### 게터 세터

* 스칼라에서는 생성자, 게터, 세터가 암시적으로 생성되므로 코드가 휠씬 단순에 진다.
```
class Student(var name: String, var id: Int)
val s = new Student("Raoul" 1)     // Student 객체 초기화
println(s.name)   // Raoul 출력
s.id = 1337    // id 설정
println(s.id)  // 1337
```

### 트레이트

* 자바의 인터페이스를 대체한다. 트레이트로 추상 메서드와 기본 구현을 가진 메서드 두 가지를 모두 정의할 수 있다.
* 자바의 인터페이스처럼 트레이트는 다중 상속을 지원하므로 자바의 인터페이스와 디폴트 메서드 기능이 합쳐진 것으로 이해할 수 있다.
```
trait Sized {
  var size : Int = 0 
  def isEmpty() = size == 0
}

class Empty extends Sized 
println(new Empty().isEmpty())
```

* 자바 인터페이스와는 달리 객체 트레이트는 **인스턴화 과정에서도 조합**할 수 있다(하지만 조합 결과는 컴파일할 때 결정된다).
```
class Box
val b1 = new Box() with Sized   // 객체를 인스턴화할 때 트레이트를 조합함
println(b1.isEmpty())     // true
val b2 = new Box()
b2.isEmpty()           // 컴파일 에러: Box 클래스 선언이 Sized를 상속하지 않았음
```
* 같은 시그니처를 갖는 메서드나 같은 이름을 갖는 필드를 정의하는 트레이트를 다중 상속하면 스칼라에서는 9장 디폴트 메서드에서 해결한 방법과 비슷한 제한을 둔다.
