# 병렬 데이터 처리와 성능

자바 7에서 추가된 **포크/조인 프레임워크**를 이용해 더 쉽게 병렬화를 수행하면서 에러를 최소화할 수 있다.

## 병렬 스트림

* 컬렉션에 `parallelStream`을 호출하면 **병렬 스트림**이 생성된다.
* 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
* 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

```java
public long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1)   // 무한 자연수 스트림 생성
        .limit(n) // n개 이하로 제한
        .reduce(0L, Long::sum);   // 모든 숫자를 더하는 스트림 리듀싱 연산
}

// 병렬 스트림으로 변환
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
    .limit(n)
    .parallel()  // 스트림을 병렬 스트림으로 변환
    .reduce(0L, Long::sum);
}
```

* `parallel` 메서드를 호출하면 기존의 함수형 리듀싱 연산(숫자 합계 계산)이 병렬로 처리된다.
* 순차 스트림에 `parallel`을 호출해도 스트림 자체에는 아무 변화도 일어나지 않는다.
* 내부적으로 `parallel`을 호출하면 이후 연산이 병렬로 수행해야 함을 의미하는 불리언 플래그가 설정된다.
* 반대로 `sequential`로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.
```java
stream.parallel()
    .filter(...)
    .sequential()
    .map(...)
    .parallel()
    .reduce();   
```
* `parallel, sequential` 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.
  * 마지막 호출은 `parallel`이므로 파이프라인은 전체적으로 병렬로 실행된다.

> ### 병렬 스트림에서 사용하는 스레드 풀 설정
> * 병렬 스트림은 내부적으로 `ForkJoinPool`을 사용한다.
> * 기본적으로 `ForkJoinPool`은 프로세스 수, 즉 `Runtime.getRuntime().availableProcessors()`가 반환하는 값에 상응하는 스레드를 갖는다.
> ```java
> System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", 12);
> ```
> * 전역 설정 코드로 모든 병렬 스트림 연산에 영향을 준다.
> * 현재는 하나의 병렬 스트림에 사용할 수 있는 특정한 값을 지정할 수 없다.
> * 일반적으로 기기의 프로세서 수와 같으므로 특별한 이유가 없다면 `ForkJoinPool`의 기본값을 그대로 사용할 것을 권장한다.

### 스트림 성능 측정

* 병렬화를 이용하면 순차나 반복 형식에 비해 성능이 더 좋아질 것이라 추측한다. 하지만 소프트웨어 공학에서 추측은 위험한 방법이다.
* 자바에서 성능 측정을 위한 JMH라는 라이브러리를 이용해 작은 벤치마크를 구현할 수 있다.

### 병렬 스트림의 올바른 사용법

* 병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다.

```java
public long sidEffectSum(long n) {
    Accumulator accumulator = new Accumulator();
    LongStream.rangeClosed(1, n).forEach(accumulator::add);
    return accumulator.total;
}

public class Accumulator {
    public long total = 0;
    public void add(long value) {
        total += value;
    }
}
```

* 위 코드는 누적자를 초기화하고, 리스트의 각 요소를 하나씩 탐색하면서 누적자에 숫자를 추가할 수 있다.
* 위 코드는 순차 실행할 수 있도록 구현되어 있으므로 병렬로 실행하면 참사가 일어난다. 
  * 특히 `total`을 접근할 때마다 동기화 문제가 발생한다.
  * 동기화 문제를 해결하다보면 결국 병렬화라는 특성이 없어져 버릴 것이다.
* 병렬 스트림과 병렬 계산에서는 공유된 가변 상태를 피해야 한다.

### 병렬 스트림 효과적으로 사용하기

* **확신이 서지 않으면 직접 측정하라.** 
  * 순차 스트림을 병렬스트림으로 쉽게 바꿀 수 있다. 하지만 무조건 병렬 스트림으로 바꾸는 것이 능사는 아니다.
  * 따라서 순차 스트림과 병렬 스트림 중 어떤 것이 좋을지 모르겠다면 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.
    <br><br>
* **박싱을 주의하라.**
  * 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다.
  * 자바 8은 박싱 동작을 피할 수 있도록 기본형 특화 스트림(`IntStream, LongStream, DoubleStream`)을 제공한다.
  * 따라서 되도록이면 기본형 특화 스트림을 사용하는 것이 좋다.
    <br><br>
* **순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산을 피하자.**
  * 특히 `limit, findFirst`처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다.
  * `findAny`는 요소의 순서와 상관없이 연산하므로 `findFirst`보다 성능이 좋다.
  * 정렬된 스트림에 `unordered`를 호출하면 비정렬된 스트림을 얻을 수 있다. 
  * 스트림에 N개 요소가 있을 때 요소의 순서가 상관없다면 비정렬된 스트림에 `limit`를 호출하는 것이 더 효율적이다.
    <br><br>
* **스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.**
  * 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는 데 드는 비용을 Q라 하면 전체 스트림 파이프라인 처리 비용을 N * Q로 예상할 수 있다.
  * Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미한다.
<br><br>
* **소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.**
  * 소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는 부가 비용을 상쇄할 수 있을 만큼의 이득을 얻지 못하기 때문이다.
<br><br>
* **스트림을 구성하는 자료구조가 적절한지 확인하라.**
  * `ArrayList`를 `LinkedList`보다 효율적으로 분할할 수 있다. `LinkedList`는 모든 요소를 탐색해야 하지만 `ArrayList`는 요소를
   탐색하지 않고도 리스트를 분할할 수 있다.
  * 또한 `range` 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해할 수 있다.
  * 커스텀 `Spliterator`를 구현해서 분해 과정을 완벽하게 제어할 수 있다.
<br><br>
* **스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.**
  * `SIZED`스트림은 정확히 같은 크기로 분할하여 병렬 처리에 효과적이지만 필터 연산은 스트림의 길이를 예측할 수 없어 효과적으로 병렬 처리가 가능한지
   알 수 없다.
    <br><br>
* **최종 연산의 병합 과정 비용을 살펴보라.**
  * 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.

## 포크/조인 프레임워크

* 포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록
 설계되었다.
* 포크/조인 프레임워크에서는 서브태스크를 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 `ExecutorService` 인터페이스를 구현한다.

### RecursiveTask 활용

* 스레드 풀을 이용하려면 `RecursiveTask<R>`의 서브클래스를 만들어야 한다.
* 여기서 R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때(결과가 없더라도 다른 비지역 구조를 바꿀 수 있다)는 `RecursiveAction` 형식이다.
* `RecursiveTask`를 정의하려면 추상 메서드 `compute`를 구현해야 한다.
```java
protected abstract R compute();
```

* `compute` 메서드는 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의한다.
```java
// 분할 정복 알고리즘의 병렬화 버전이다.
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함
    모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}
```

* 일반적으로 애플리케이션에서는 둘 이상의 `ForkJoinPool`을 사용하지 않는다.
* 즉, 소프트웨어의 필요한 곳에서 언제든 가져다 쓸 수 있도록 `ForkJoinPool`을 한 번만 인스턴스화해서 정적필드에 싱글턴으로 저장한다.
* `ForkJoinPool`을 만들면서 인수가 없는 디폴트 생성자를 이용했는데, 이는 `JVM`에서 이용할 수 있는 모든 프로세서가 자유롭게 풀에 접근할 수 있음을 의미한다.
* 더 정확하게는 `Runtime.availableProcessors`의 반환값으로 풀에 사용할 스레드 수를 결정한다.
* `availableProcessors`, 즉 '사용할 수 있는 프로세서'라는 이름과는 달리 실제 프로세서외에 하이퍼스레딩과 관련된 가상 프로세서도 개수에 포함한다.

### 포크/조인 프레임워크를 제대로 사용하는 방법

* `join` 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때가지 호출자를 블록시킨다.
  * 따라서 두 서브태스크가 모두 시작된 다음에 `join`을 호출해야한다. 그렇지 않으면 각각의 서브태스크가 다른 태스크가 끝나길 기다리는 일이 발생하며
   원래 순차 알고리즘보다 느리고 복잡한 프로그램이 되어버릴 수 있다.

* `RecursiveTask` 내에서는 `ForkJoinPool`의 `invoke` 메서드를 사용하지 말아야 한다.
  * 대신 `compute`나 `fork` 메서드를 직접 호출할 수 있다. 순차 코드에서 병렬 계산을 시작할 때만 `invoke`를 사용한다.

* 서브태스크에 `fork` 메서드를 호출해서 `ForkJoinPool`의 일정을 조절할 수 있다.
  * 왼쪽 작업과 오른쪽 작업 모두에 `fork` 메서드를 호출하는 것이 자연스러울 것 같지만 한쪽 작업에는 `fork`를 호출하는 것보다는 `compute`를 호출하는 것이
   효율적이다.
  * 그러면 두 서브태스크의 한 태스크에는 같은 스레드를 재사용할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할 수 있다.

* 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.

* 병렬 스트림에서 살펴본 것처럼 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거라는 생각은 버려야 한다.
  * 성능을 측정할 때는 지금까지 살펴본 하니스에서 그랬던 것처럼 여러 번 프로그램을 실행한 결과를 측정해야 한다. 또한 컴파일러 최적화는
   병렬 버전보다는 순차 버전에 집중될 수 있다는 사실도 기억하자.

### 작업 훔치기

* 포크/조인 프레임워크에서는 **작업 훔치기**라는 기법을 이용해 `ForkJoinPool`의 모든 스레드를 거의 공정하게 분할한다.
* 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리한다.
* 이때 한 스레드는 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리할 수 있다. 즉, 다른 스레드는 바쁘게 일하고 있는데 한 스레드는 할일이 다떨어진 상황이다.
 이때 할일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 모든 태스크가 작업을 끝낼 때 가지,
* 즉 모든 큐가 빌 때가지 이 과정을 반복한다. 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업부하를 비슷한 기준으로 유지할 수 있다.

## Spliterator 인터페이스

* 자바 8은 `Spliterator`라는 인터페이스를 제공한다. `Spliterator`는 '분할할 수 있는 반복자'라는 의미다.
* `Iterator`처럼 소스의 요소 탐색 기능을 제공하지만 `Spliterator`는 병렬 작업에 특화되어 있다.
* 자바 8은 컬렉션 프레임워크에 포함된 모든 자료구조에 사용할 수 있는 디폴트 `Spliterator` 구현을 제공한다.
```java
public interface Spliterator<T> {
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```

* `T`는 `Spliterator`에서 탐색하는 요소의 형식을 가리킨다.
* `tryAdvance` 메서드는 `Spliterator`의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환한다(즉, 일반적인 Iterator 동작과 같다).
* `trySplit` 메서드는 `Spliterator`의 일부 요소(자신이 반환한 요소)를 분할해서 두 번째 `Spliterator`를 생성하는 메서드다.
* `estimateSize` 메서드는 탐색해야 할 요소 수 정보를 제공할 수 있다.
  * 특히 탐색해야 할 요소 수가 정확하진 않더라도 제공된 값을 이용해서 더 쉽고 공평하게 `Spliterator`를 분할할 수 있다.
* `characteristics` 메서드는 `Spliterator` 자체의 특성 집합을 포함하는 `int`를 반환한다.

## 정리

* 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다.
* 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다.
  * 병렬 소프트웨어 동작 방법과 성능은 직관적이지 않을 때가 많으므로 병렬 처리를 사용했을때 성능을 직접 측정해봐야 한다.
* 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 성능을 높일 수 있다.
* 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
* 포크/조인 프레임워크에서는 병렬화할 수 잇는 태스크를 작은 태스크로 분할한 다음에 분할된 태스크를 각각의 스레드로 실행하며 서브태스크 각각의
 결과를 합쳐서 최종 결과를 생산한다.
* `Spliterator`는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화할 것인지 정의한다.