# 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## 1.1 역사의 흐름은 무엇인가?

* 자바 역사를 통틀어 가장 큰 변화는 자바 8에서 일어났다.
```java
Collection.sort(inventorym new Comparator<Apple>()) {
    public in compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
}

// 위 코드를 자바 8을 이용해 간결하게 표현
inventory.sort(comparing(Apple::getWeight));
```

* 자바 8 등장 전 멀티 코어의 나머지 코어를 활용하려면 스레드를 사용하라는 조언이 있었다.
* 하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.
* 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.


* **자바 1.0** : 스레드와 락(lock), 메모리 모델 지원
  * 저수준 기능으로 온전히 활용하기 어려움

* **자바 5** : 스레드풀, 병렬 실행 컬렉션 등 강력한 도구 도입

* **자바 7** : 병렬 실행에 도움을 줄 수 있는 `포크/조인 프레임워크`를 제공했지만 활용하기 어려움

* **자바 8** : 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법 제공


* **자바 8**은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.
* **자바 8**에서 제공하는 새로운 기술
  * **스트림 API**
  * **메서드에 코드를 전달하는 기법**
  * **인터페이스의 디폴트 메서드**

## 1.2 왜 아직도 자바는 변화하는가?

* 새로운 언어가 등장하면서 진화하지 않은 기존 언어는 사장되었다. 우리는 완벽한 언어를 원하지만 현실적으로 존재하지 않으며 모든 언어가 장단점을 가지고 있다.
  * c, c++는 프로그래밍 안전성은 부족하지만 작은 런타임 풋프린트 덕분에 운영체제와 다양한 임베디드 시스템에서는 여전히 인기있다.
* 특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다.
* 자바는 처음 부터 많은 유용한 라이브러리를 포함했고 스레드와 락을 이용한 소소한 동시성도 지원했다.
* 코드를 `jvm` 바이트 코드로 컴파일하는 특징 때문에 인터넷 애플리케이션 프로그램의 주요 언어가 되었다.
* 이후 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다.
  * 즉, 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었다.
* 자바 8은 이러한 변화에 맞추어 이전에 없던 완전히 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다.

### 자바 8 세 가지 프로그래밍 개념

#### 1. 스트림 처리

* 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
* 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 자바 8에서는 작업을 고수준으로 추상화에서 일련의 스트림으로 만들어 처리 할 수 있다는 것이다.
* 또한 스트림 파이프라인을 이용해서 입력 뿐을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다.
* 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

#### 2. 동작 파라미터화로 메서드에 코드 전달하기

* 코드 일부를 API로 전달하는 기능이다.
* 자바 8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없었다.
* 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.

#### 3. 병렬성과 공유 가변 데이터

* 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.
* 보통 다른 코드와 동시에 실행하더라도 **안전하게 실행**할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다.
* 이러한 함수를 순수(pure) 함수, 부작용 없는(side-effect-free) 함수, 상태 없는(stateless) 함수라고 부른다.
* 물론 기존처럼 `synchronized`를 이용해 가변 데이터를 보호할 순 있지만 일반적으로 `synchronized`는 시스템 성능에 악영향을 미친다.
* 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두가지 기능은 **함수형 프로그래밍** 패러다임의 핵심적인 사항이다.


## 1.3 자바 함수

* 프로그래밍 언어의 핵심은 값을 바꾸는 것이다.
* 역사적으로 그리고 전통적으로 프로그래밍 언어에서는 이값을 일급(first-class)값이라 부른다.
* 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다.
* 이렇게 전달 할 수 없는 구조체는 이급 시민이다. 위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 시민에 해당한다.
* 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다.
* 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

### 메서드와 람다를 일급 시민으로

```java
// 자바 8 이전
File[] hiddenFiles = new File(".").listFiles(new FilesFilter() {
   public boolean accept(File file) {
       return file.isHidden();
    } 
});

// 자바 8
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

#### 메서드 참조

* 위 코드는 자바 8의 **메서드 참조 ::**(이 메서드를 값으로 사용하라는 의미)를 이용해서 `listFiles`에 직접 전달하고 있다.
* 기존 객체 참조를 이용해서 객체를 이리저리 주고받았던 것처럼 자바 8에서는 메서드 참조를 만들어 전달할 수 있게 되었다.

#### 람다 : 익명 함수

* 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 **람다(또는 익명함수)** 를 포함하여 함수도 값으로 취급할 수 있다.
