# CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

* 최근 소프트웨어 개발 방법을 획기적으로 뒤집는 두 가지 추세가 있다.
  * 한 가지는 애플리케이션을 실행하는 하드웨어와 관련된 것이고 다른 하나는 애플리케이션을 어떻게 구성하는가와 관련된 것이다.
* 멀티코어 프로세서가 발전하면서 애플리케이션의 속도는 멀티 코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라질 수 있음을 확인했다.
* 두 번째 추세는 인터넷 서비스에서 사용하는 애플리케이션이 증가하고 있는 현상을 반영한다. 예를 들어 마이크로서비스 아키텍처 선택이 지난 몇 년간 증가했다.
 하나의 거대한 애플리케이션 대신 작은 서비스로 애플리케이션을 나누는 것이다. 서비스가 작아진 대신 네트워크 통신이 증가한다. 즉 앞으로 만들 웹 애플리케이션은
 다양한 소스의 콘텐츠를 가져와서 사용자가 삶을 풍요롭게 만들도록 합치는 매시업 형태가 될 가능성이 크다. 이런 애플리케이션을 구현하려면 인터넷으로
 여러 웹서비스에 접근해야 한다. 하지만 이들 서비스의 응답을 기다리는 동안 연산이 블록되거나 귀중한 CPU 클록 사이클 자원을 낭비하고 싶진 않다. 
    * 자바는 이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공한다.
      1. 자바 8의 `CompletableFuture` 제공
      2. 자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그램 개념을 따르는 플로 API는 조금 더 정교한 프로그래밍 접근 방법을 제공한다.

## 동시성을 구현하는 자바 지원의 진화

* 초기 자바는 `Runnable`과 `Thread`를 동기화된 클래스와 메서드를 이용해 잠갔다.
* 2004년 자바 5는 좀 더 표현력있는 동시성을 지원하는 특히 스레드 실행과 태스크 제출을 분리하는 `ExecutorService` 인터페이스, 높은 수준의 결과
 즉, `Runnable, Thread`의 변형을 반환하는 `Callable<T> and Future<T>`, 제네릭 등을 지원했다.
* 멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에서는 개선된 동시성 지원이 추가되었다.
* 자바 7에서는 분할 그리고 정복 알고리즘의 포크/조인 구현을 지원하는 `java.util.concurrent.RecursiveTask`가 추가되었다.
* 자바 8에서는 스트림과 새로 추가된 람다 지원에 기반한 병렬 프로세싱, `Future`를 조합하는 기능을 추가하면서 동시성을 강화했다.
* 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다. 이 과정을 리액티브 프로그래밍이라 부르며 발행-구독 프로토콜로 이를 지원한다.
  * `CompletableFuture, java.util.concurrent.Flow`의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게
   만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.

### 스레드와 높은 수준의 추상화

* 프로세스는 다시 운영체제에 한 개 이상의 **스레드** 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 태스크를 동시에 또는
 협력적으로 실행할 수 있다.
* 병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념이라는 사실을 알 수 있다. 다시 말해 스트림을 이용해 스레드 사용 패턴을 **추상화**할 수 있다.
* 스트림으로 추상화하는 것은 디자인 패턴을 적용하는 것과 비슷하지만 대신 쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성이 줄어든다는 장점이 더해진다.
* 자바 7의 `java.util.concurrent.RecursiveTask` 지원 덕분에 포크/조인 스레드 추상화로 분할 그리고 정복 알고리즘을 병렬화하면서 멀티코어 머신에서
 배열의 합을 효율적으로 계산하는 높은 수준의 방식을 제공하는 방법을 설명했다.

### Executor와 스레드 풀

* 자바 5는 `Executor` 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을
 분리할 수 있는 기능을 제공했다.

#### 스레드의 문제

* 자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼비용(페이지 테이블과 관련한 상호 작용)을 치러야 하며
 더욱이 운영체제 스레드의 숫자는 제한되어 있는 것이 문제다.
* 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크래시될 수 있으므로 기존 스레드가 실행되는 상태에서 계속
 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다.
* 보통 운영체제와 자바의 스레드 개수가 하드웨어 스레드 개수보다 많으므로 일부 운영 체제 스레드가 블록되거나 자고 있는 상황에서 모든 하드웨어
 스레드가 코드를 실행하도록 할당된 상황에 놓을 수 있다.
* 프로그램에서 사용할 최적의 자바 스레드 개수는 사용할 수 있는 하드웨어 코어의 개수에 따라 달라진다.

#### 스레드 풀 그리고 스레드 풀이 더 좋은 이유

* 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다. 이들 태스크 실행이 종료되면 이들 스레드를 풀로 반환한다.
* 이 방식의 장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.
* 큐의 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위 등 다양한 설정을 할 수 있다.
* 프로그래머는 **태스크**(Runnable이나 Callable)를 제공하면 **스레드**가 이를 실행한다.

#### 스레드 풀 그리고 스레드 풀이 나쁜 이유

* 거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 "사항"을 주의해야 한다.

1. K 스레드를 가진 스레드 풀은 오직 K만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기
 전까지는 스레드에 할당하지 않는다. 불필요하게 많은 스레드를 만드는 일을 피할 수 있으므로 보통 이 상황은 아무 문제가 되지 않지만 잠을 자거나 I/O를
 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다. I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만
 아무 작업도 하지 않게 된다. 핵심은 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드 풀에 제출하지 말아야 한다는 것이지만 항상 이를 지킬 수 있는 것은 아니다.

2. 프로그램이 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. 자바에서는 이런 상황을 다룰 수 있도록 `Thread.setDaemon` 메서드를 제공한다.

## 동기 API와 비동기 API

### Future 형식 API

```java
Future<Integer> f(int x);
Future<Integer> g(int x);
int result = y.get() + z.get();
```

* 메서드 f는 호출 즉시 자신의 원래 바디를 평가하는 태스크를 포함하는 `Future`를 반환한다. 마찬가지로 메서드 g도 `Future`를 반환하며
 세 번째 코드는 `get()` 메서드를 이용해 두 `Future`가 완료되어 결과가 합쳐지기를 기다린다.
* 예제에서는 API는 그대로 유지하고 g를 그대로 호출하면서 f에만 Future를 적용할 수 있었다.
* 하지만 조금 더 큰 프로그램에서는 두 가지 이유로 이런 방식을 사용하지 않는다.
  1. 다른 상황에서는 g에도 Future 형식이 필요할 수 있으므로 API 형식을 통일하는 것이 바람직하다.
  2. 병렬 하드웨어로 프로그램 실행 속도를 극대화하려면 여러 작은 하지만 합리적인 크기의 태스크로 나누는 것이 좋다.
* Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.

### 리액티브 형식 API

* 두 번째 대안에서 핵심은 f, g의 시그니처를 바꿔서 콜백 형식의 프로그래밍을 이용하는 것이다.

```java
public class CallbackStylesExample {
    public static void main(String[] args) {
        int x = 1337;
        Result result = new Result();
        
        f(x, (int y) -> {
            result.left = y;
            System.out.println((result.left + result.right));
        });
        
        g(x, (int z) -> {
            result.right = z;
            System.out.println((result.left + result.right));
        });
    }
}
```

* 하지만 결과가 달라졌다. f와 g의 호출 합계를 정확하게 출력하지 않고 상황에 따라 먼저 계산된 결과를 출력한다.
* 락을 사용하지 않으므로 값을 두 번 출력할 수 있을 뿐더러 때로는 +에 제공된 두 피연산자가 `println`이 호출되기 전에 업데이트될 수 있다.
* 두 가지 방법으로 이 문제를 보완할 수 있다.
  1. `if-then-else`를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 `println`을 호출해 원하는 기능을 수행할 수 있다.
  2. 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 `Future`를 이용하는 것이 더 적절하다.
* 리액티브 형식의 비동기 API는 자엽스럽게 일련의 값(나중에 스트림으로 연결)을 처리하는 데 적합하다.

### 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주

* 스레드는 잠들어도 여전히 시스템 자원을 점유한다. 스레드를 단지 몇 개 사용하는 상황에서는 큰 문제가 아니지만 스레드가 많아지고 그 중 대부분이
 잠을 잔다면 문제가 심각해진다.
* 스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다는 사실을 기억하자(운영 체제가 이들 태스크를 관리하므로 일단 스레드로 할당된
 태스크는 중지시키지 못한다).
* 이러한 상황에서는 무엇을 할 수 있을까? 이상적으로는 절대 태스크에서 기다리는 일을 만들지 말거나 아니면 코드에서 예외를 일으키는 방법으로 이를
 처리할 수 있다. 태스크를 앞과 뒤에 두 부분으로 나누고 블록되지 않을 때만 뒷부분을 자바가 스케줄링하도록 요청할 수 있다.

### 비동기 API에서 예외는 어떻게 처리하는가?

* `Future`나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의
 실행 범위와는 관계가 없는 상황이 된다.
* `Future`를 구현한 `CompletableFuture`에서는 런타임 `get()` 메서드에 예외를 처리할 수 있는 기능을 제공하며 예외에서 회복할 수 있도록
 `exceptionally()` 같은 메서드도 제공한다.
* 리액티브 형식의 비동기 API에서는 `return` 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 한다.
```java
void f(int x, Consumer<Integer> dealWithResult, Consumer<Throwable> dealWithException);
```

* 콜백이 여러 개면 이를 따로 제공하는 것보다는 한 객체로 이 메서드를 감싸는 것이 좋다. 예를 들어 자바 9 플로 API에서는 여러 콜백을 한
 객체(네 개의 콜백을 각각 대표하는 네 메서드를 포함하는 Subscriber<T> 클래스)로 감싼다.
```java
void onComplete()
void onError(Throwable throwable)
void onNext(T item)
```
* 값이 있을 때(onNext), 도중에 에러가 발생했을 때(onError), 값을 다 소진했거나 에러가 발생해서 더 이상 처리할 데이터가 없을 때(onComplete) 각각의
 콜백이 호출된다.
* 보통 이런 종류의 호출을 메시지 또는 **이벤트**라 부른다.

## CompletableFuture와 콤비네이터를 이용한 동시성

* 자바 8에서는 `Future` 인터페이스의 구현인 `CompletableFuture`를 이용해 `Future`를 조합할 수 있는 기능을 추가했다.
* 일반적으로 `Future`는 실행해서 `get()`으로 결과를 얻을 수 있는 `Callable`로 만들어진다. 하지만
 `CompletableFuture`는 실행할 코드 없이 `Future`를 만들 수 있도록 허용하며 `complete()` 메서드를 이용해 나중에 어떤 값을 이용해
 다른 스레드가 이를 완료할 수 있고 `get()`으로 값을 얻을 수 있도록 허용한다.
* 하지만 어떤 상황에서는 많은 수의 `Future`를 사용해야 한다. 이런 상황에서는 `CompletableFuture`와 콤비네이터를 이용해 `get()`에서
 블록하지 않을 수 있고 그렇게 함으로 병렬 실행의 효율성은 높이고 데드락은 피하는 최상의 해결책을 구현할 수 있다.

## 발행-구독 그리고 리액티브 프로그래밍

* `Future`와 `CompletableFuture`은 독립적 실행과 병렬성이라는 정식적 모델에 기반한다.
* 연산이 끝나면 `get()`으로 `Future`의 결과를 얻을 수 있다. 따라서 `Future`는 한 번만 실행해 결과를 제공한다.
* 반면 리액티브 프로그래밍은 시간이 흐르면서 여러 `Future` 같은 객체를 통해 여러 결과를 제공한다.
* 자바 9에서는 `java.util.concurrent.Flow`의 인터페이스에 발행-구독 모델(줄여서 pub-sub이라 불리는 프로토콜)을 적용해
 리액티브 프로그래밍을 제공한다.
* 자바 9 플로 API는 세 가지로 플로 API를 정리할 수 있다.
  1. 구독자가 구독할 수 있는 **발행자**
  2. 이 연결을 **구독(subscription)** 이라 한다.
  3. 이 연결을 이용해 **메시지(또는 이벤트로 알려짐)** 를 전송한다.

* 데이터가 발행자(생산자)에서 구독자(소비자)로 흐름에 착안해 개발자는 이를 **업스트림** 또는 **다운스트림**이라 부른다.
* 자바 9 플로 API의 `Subscriber`에서는 실제 `onError`와 `onComplete`를 지원한다. 기존의 옵저버 패턴에 비해 새로운 API 프로토콜이
 더 강력해진 이유가 이들 바로 이런 메서드 덕분이다.
* 간단하지만 플로 인터페이스의 개념을 복자하게 만든 두 가지 기능은 압력과 역압력이다. 자바 9 플로 API에서는 발행자가 무한의 속도로 아이템을
 방출하는 대신 요청했을 때만 다음 아이템을 보내도록 하는 `request()` 메서드(Subscription이라는 새 인터페이스에 포함)를 제공한다

### 역압력

```java
void onSubscribe(Subscription subscription);
```
* `Publisher`와 `Subscriber` 사이에 채널이 연결되면 첫 이벤트로 이 메서드가 호출된다. `Subscription` 객체는 다음처럼 `Subscriber`와
 `Publisher`와 통신할 수 있는 메서드를 포함한다.
```java
interface Subscription {
    void cancel();
    void request(long n);
}
```
* 콜백을 통한 역방향 소통 효과에 주목하자. `Publisher`는 `Subscription` 객체를 만들어 `Subscriber`로 전달하면 `Subscriber`는 이를
 이용해 `Publisher`로 정보를 보낼 수 있다.

### 실제 역압력의 간단한 형태

* 한번에 한 개의 이벤트를 처리하도록 발행-구독 연결을 구성하려면 다음과 작업이 필요하다.
  * `Subscriber`가 `OnSubscribe`로 전달된 `Subscription` 객체를 `subscription` 같은 필드에 로컬로 저장한다.
  * `Subscriber`가 수많은 이벤트를 받지 않도록 `onSubscribe, onNext, onError`의 마지막 동작에 `channel.request(1)`을 추가해 
   오직 한 이벤트만 요청한다.
  * 요청을 보낸 채널에만 `onNext, onError` 이벤트를 보내도록 `Publisher`의 `notifyAllSubscribers` 코드를 바꾼다(보통 여러
   `Subscriber`가 자신만의 속도를 유지할 수 있도록 `Publisher`는 새 `Subscription`을 만들어 각 `Subscriber`와 연결한다).
* 구현은 간다해 보일 수 있지만 역압력을 구현하려면 여러가지 장단점을 생각해야 한다.
  * 여러 `Subscriber`가 있을 때 이벤트를 가장 느린 속도로 보낼 것인가? 아니면 각 `Subscriber`에게 보내지 않은 데이터를 저장할 별도의 큐를 가질 것인가?
  * 큐가 너무 커지면 어떻게 해야 할까?
  * `Subscriber`가 준비가 안 되었다면 큐의 데이터를 폐기할 것인가?
* 위 질문의 답변은 데이터 성격에 따라 달라진다.

## 리액티브 시스템 vs 리액티브 프로그래밍

### 리액티브 시스템

* 런타임 환경의 변화에 대응하도록 전체 아키텍처가 설계된 프로그램을 가리킨다.
* 반응성, 회복성, 탄력성으로 세 가지 속성을 요약할 수 있다.
* 반응성은 리액티브 시스템이 큰 작업을 처리하느라 간단한 질의의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것을 의미한다.
* 회복성은 한 컴포넌트의 실패로 전체 시스템이 실패하지 않음을 의미한다.
* 탄력성은 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미한다.

### 리액티브 프로그래밍

* 리액티브 프로그래밍을 통해 리액티브 시스템을 구현할 수 있다.
* 자바는 `java.util.concurrent.Flow` 관련된 자바 인터페이스에서 제공하는 리액티브 프로그래밍 형식을 이용하는 것도 주요 방법 중 하나다.
