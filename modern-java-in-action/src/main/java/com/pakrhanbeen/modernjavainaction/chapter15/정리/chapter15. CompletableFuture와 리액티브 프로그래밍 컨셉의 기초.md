# CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

* 최근 소프트웨어 개발 방법을 획기적으로 뒤집는 두 가지 추세가 있다.
  * 한 가지는 애플리케이션을 실행하는 하드웨어와 관련된 것이고 다른 하나는 애플리케이션을 어떻게 구성하는가와 관련된 것이다.
* 멀티코어 프로세서가 발전하면서 애플리케이션의 속도는 멀티 코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라질 수 있음을 확인했다.
* 두 번째 추세는 인터넷 서비스에서 사용하는 애플리케이션이 증가하고 있는 현상을 반영한다. 예를 들어 마이크로서비스 아키텍처 선택이 지난 몇 년간 증가했다.
 하나의 거대한 애플리케이션 대신 작은 서비스로 애플리케이션을 나누는 것이다. 서비스가 작아진 대신 네트워크 통신이 증가한다. 즉 앞으로 만들 웹 애플리케이션은
 다양한 소스의 콘텐츠를 가져와서 사용자가 삶을 풍요롭게 만들도록 합치는 매시업 형태가 될 가능성이 크다. 이런 애플리케이션을 구현하려면 인터넷으로
 여러 웹서비스에 접근해야 한다. 하지만 이들 서비스의 응답을 기다리는 동안 연산이 블록되거나 귀중한 CPU 클록 사이클 자원을 낭비하고 싶진 않다. 
    * 자바는 이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공한다.
      1. 자바 8의 `CompletableFuture` 제공
      2. 자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그램 개념을 따르는 플로 API는 조금 더 정교한 프로그래밍 접근 방법을 제공한다.

## 동시성을 구현하는 자바 지원의 진화

* 초기 자바는 `Runnable`과 `Thread`를 동기화된 클래스와 메서드를 이용해 잠갔다.
* 2004년 자바 5는 좀 더 표현력있는 동시성을 지원하는 특히 스레드 실행과 태스크 제출을 분리하는 `ExecutorService` 인터페이스, 높은 수준의 결과
 즉, `Runnable, Thread`의 변형을 반환하는 `Callable<T> and Future<T>`, 제네릭 등을 지원했다.
* 멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에서는 개선된 동시성 지원이 추가되었다.
* 자바 7에서는 분할 그리고 정복 알고리즘의 포크/조인 구현을 지원하는 `java.util.concurrent.RecursiveTask`가 추가되었다.
* 자바 8에서는 스트림과 새로 추가된 람다 지원에 기반한 병렬 프로세싱, `Future`를 조합하는 기능을 추가하면서 동시성을 강화했다.
* 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다. 이 과정을 리액티브 프로그래밍이라 부르며 발행-구독 프로토콜로 이를 지원한다.
  * `CompletableFuture, java.util.concurrent.Flow`의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게
   만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.

### 스레드와 높은 수준의 추상화

* 프로세스는 다시 운영체제에 한 개 이상의 **스레드** 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로 태스크를 동시에 또는
 협력적으로 실행할 수 있다.
* 병렬 스트림 반복은 명시적으로 스레드를 사용하는 것에 비해 높은 수준의 개념이라는 사실을 알 수 있다. 다시 말해 스트림을 이용해 스레드 사용 패턴을 **추상화**할 수 있다.
* 스트림으로 추상화하는 것은 디자인 패턴을 적용하는 것과 비슷하지만 대신 쓸모 없는 코드가 라이브러리 내부로 구현되면서 복잡성이 줄어든다는 장점이 더해진다.
* 자바 7의 `java.util.concurrent.RecursiveTask` 지원 덕분에 포크/조인 스레드 추상화로 분할 그리고 정복 알고리즘을 병렬화하면서 멀티코어 머신에서
 배열의 합을 효율적으로 계산하는 높은 수준의 방식을 제공하는 방법을 설명했다.

### Executor와 스레드 풀

* 자바 5는 `Executor` 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어올리는 즉 자바 프로그래머가 태스크 제출과 실행을
 분리할 수 있는 기능을 제공했다.

#### 스레드의 문제

* 자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼비용(페이지 테이블과 관련한 상호 작용)을 치러야 하며
 더욱이 운영체제 스레드의 숫자는 제한되어 있는 것이 문제다.
* 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크래시될 수 있으므로 기존 스레드가 실행되는 상태에서 계속
 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 한다.
* 보통 운영체제와 자바의 스레드 개수가 하드웨어 스레드 개수보다 많으므로 일부 운영 체제 스레드가 블록되거나 자고 있는 상황에서 모든 하드웨어
 스레드가 코드를 실행하도록 할당된 상황에 놓을 수 있다.
* 프로그램에서 사용할 최적의 자바 스레드 개수는 사용할 수 있는 하드웨어 코어의 개수에 따라 달라진다.

#### 스레드 풀 그리고 스레드 풀이 더 좋은 이유

* 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행한다. 이들 태스크 실행이 종료되면 이들 스레드를 풀로 반환한다.
* 이 방식의 장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.
* 큐의 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위 등 다양한 설정을 할 수 있다.
* 프로그래머는 **태스크**(Runnable이나 Callable)를 제공하면 **스레드**가 이를 실행한다.

#### 스레드 풀 그리고 스레드 풀이 나쁜 이유

* 거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 "사항"을 주의해야 한다.

1. K 스레드를 가진 스레드 풀은 오직 K만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기
 전까지는 스레드에 할당하지 않는다. 불필요하게 많은 스레드를 만드는 일을 피할 수 있으므로 보통 이 상황은 아무 문제가 되지 않지만 잠을 자거나 I/O를
 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다. I/O를 기다리는 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만
 아무 작업도 하지 않게 된다. 핵심은 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드 풀에 제출하지 말아야 한다는 것이지만 항상 이를 지킬 수 있는 것은 아니다.

2. 프로그램이 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. 자바에서는 이런 상황을 다룰 수 있도록 `Thread.setDaemon` 메서드를 제공한다.

## 동기 API와 비동기 API

### Future 형식 API

```java
Future<Integer> f(int x);
Future<Integer> g(int x);
int result = y.get() + z.get();
```

* 메서드 f는 호출 즉시 자신의 원래 바디를 평가하는 태스크를 포함하는 `Future`를 반환한다. 마찬가지로 메서드 g도 `Future`를 반환하며
 세 번째 코드는 `get()` 메서드를 이용해 두 `Future`가 완료되어 결과가 합쳐지기를 기다린다.
* 예제에서는 API는 그대로 유지하고 g를 그대로 호출하면서 f에만 Future를 적용할 수 있었다.
* 하지만 조금 더 큰 프로그램에서는 두 가지 이유로 이런 방식을 사용하지 않는다.
  1. 다른 상황에서는 g에도 Future 형식이 필요할 수 있으므로 API 형식을 통일하는 것이 바람직하다.
  2. 병렬 하드웨어로 프로그램 실행 속도를 극대화하려면 여러 작은 하지만 합리적인 크기의 태스크로 나누는 것이 좋다.
* Future 형식의 API는 일회성의 값을 처리하는 데 적합하다.

### 리액티브 형식 API

* 두 번째 대안에서 핵심은 f, g의 시그니처를 바꿔서 콜백 형식의 프로그래밍을 이용하는 것이다.

```java
public class CallbackStylesExample {
    public static void main(String[] args) {
        int x = 1337;
        Result result = new Result();
        
        f(x, (int y) -> {
            result.left = y;
            System.out.println((result.left + result.right));
        });
        
        g(x, (int z) -> {
            result.right = z;
            System.out.println((result.left + result.right));
        });
    }
}
```

* 하지만 결과가 달라졌다. f와 g의 호출 합계를 정확하게 출력하지 않고 상황에 따라 먼저 계산된 결과를 출력한다.
* 락을 사용하지 않으므로 값을 두 번 출력할 수 있을 뿐더러 때로는 +에 제공된 두 피연산자가 `println`이 호출되기 전에 업데이트될 수 있다.
* 두 가지 방법으로 이 문제를 보완할 수 있다.
  1. `if-then-else`를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 `println`을 호출해 원하는 기능을 수행할 수 있다.
  2. 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 `Future`를 이용하는 것이 더 적절하다.
* 리액티브 형식의 비동기 API는 자엽스럽게 일련의 값(나중에 스트림으로 연결)을 처리하는 데 적합하다.

### 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주

* 스레드는 잠들어도 여전히 시스템 자원을 점유한다. 스레드를 단지 몇 개 사용하는 상황에서는 큰 문제가 아니지만 스레드가 많아지고 그 중 대부분이
 잠을 잔다면 문제가 심각해진다.
* 스레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다는 사실을 기억하자(운영 체제가 이들 태스크를 관리하므로 일단 스레드로 할당된
 태스크는 중지시키지 못한다).
* 이러한 상황에서는 무엇을 할 수 있을까? 이상적으로는 절대 태스크에서 기다리는 일을 만들지 말거나 아니면 코드에서 예외를 일으키는 방법으로 이를
 처리할 수 있다. 태스크를 앞과 뒤에 두 부분으로 나누고 블록되지 않을 때만 뒷부분을 자바가 스케줄링하도록 요청할 수 있다.

### 비동기 API에서 예외는 어떻게 처리하는가?

* `Future`나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의
 실행 범위와는 관계가 없는 상황이 된다.
* `Future`를 구현한 `CompletableFuture`에서는 런타임 `get()` 메서드에 예외를 처리할 수 있는 기능을 제공하며 예외에서 회복할 수 있도록
 `exceptionally()` 같은 메서드도 제공한다.
* 리액티브 형식의 비동기 API에서는 `return` 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 한다.
```java
void f(int x, Consumer<Integer> dealWithResult, Consumer<Throwable> dealWithException);
```

* 콜백이 여러 개면 이를 따로 제공하는 것보다는 한 객체로 이 메서드를 감싸는 것이 좋다. 예를 들어 자바 9 플로 API에서는 여러 콜백을 한
 객체(네 개의 콜백을 각각 대표하는 네 메서드를 포함하는 Subscriber<T> 클래스)로 감싼다.

