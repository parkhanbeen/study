# 스트림 소개

## 스트림이란 무엇인가?

* 스트림은 자바 8 API에 새로 추가된 기능이다.
* 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다.
* 스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 **투명하게** 병렬로 처리할 수 있다.

### 스트림 장점

* 선언형으로 코드를 구현할 수 있다.
  * 즉, 루프와 `if` 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요 없이 동작의 수행을 지정할 수 있다.
  * 기존 코드를 복사하여 붙여 넣는 방식을 사용하지 않고 람다 표현식을 이용해 쉽게 구현할 수 있다.
* `filter, sorted, map, collect` 같은 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.
  * `filter, sorted, map, collect` 같은 연산은 **고수준 빌딩 블록**으로 이루어져 있으므로 특정 스레딩 모델에 제한되지 않고 자유롭게
   어떤 상황에서든 사용할 수 있다.
  * 결과적으로 우리는 데이터 처리 과정을 병렬화하면서 스레드와 락을 걱정할 필요가 없다.

이러한 특징을 다음처럼 요약한다.

* **선언형** : 더 간결하고 가독성이 좋아진다.
* **조립할 수 있음** : 유연성이 좋아진다.
* **병렬화** : 성능이 좋아진다.

## 컬렉션과 스트림

* 자바 8 컬렉션에는 스트림을 반환하는 `stream` 메서드가 추가됐다. [스트림 공식 문서](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)
* 스트림이란 `데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소`로 정의할 수 있다.


* **연속된 요소** 
  * 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
  * 컬렉션은 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. (`ArrayList`를 사용할지 `LinkedList`를 사용할지)
  * 스트림은 `filter, sorted, map`처럼 표현 계산식이 주를 이룬다.
  * 즉, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.

* **소스**
  * 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
  * 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
  * 즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.

* **데이터 처리 연산**
  * 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
  * 예를들어 `filter, map, reduce, find, match, sort`등으로 데이터를 조작할 수 있다.
  * 스트림 연산은 순차적으로 또는 병렬로 실행할 수 있다.

### 스트림 두 가지 특징

* **파이프라이닝**
  * 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다.
  * 그 덕분에 **게으름, 쇼트서킷** 같은 최적화도 얻을 수 있다.
* **내부 반복**
  * 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

### 컬렉션과 스트림의 차이

* 데이터를 **언제** 계산하느냐가 컬렉션과 스트림의 가장 큰 차이다.
* 컬렉션은 현재 자료구조가 포함하는 **모든** 값을 메모리에 저장하는 자료구조다.
  * 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야한다.
* 반면 스트림은 이론적으로 **요청할 때만 요소를 계산**하는 고정된 자료구조다.
  * 결과적으로 스트림은 생산자와 소비자 관계를 형성한다.
  * 또한 스트림은 게으르게 만들어지는 컬렉션과 같다.
  * 즉, 사용자가 데이터를 요청할 때만 값을 계산한다.

### 딱 한 번만 탐색할 수 있다

* 반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다.
  * 즉, 탐색된 스트림의 요소는 소비된다.
* 반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

```java
List<String> title = Arrays.asList("Java8", "In", "Action");
Stream<String> s = title.stream();
s.forEach(System.out::println);  // title의 각 단어를 출력
s.forEach(System.out::println);  // java.lang.IllegalStateException: 스트림이 이미 소비되었거나 닫힘
```

* 스트림은 단 한 번만 소비할 수 있다는 점을 명심하자!

### 외부 반복과 내부 반복

* 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. 이를 **외부 반복**이라고 한다.
  * 즉, 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다.
* 스트림 라이브러리는 (반복을 알아서 치라하고 결과 스트림 값을 어딘가에 저장해주는) **내부 반복**을 사용한다.
  * 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.
  * 외부 반복으로 처리한다면 이와 같은 최적화를 달성하기 어렵다.
  * 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다.
  * 반면 `for-each`를 이용하는 외부 반복에서는 병렬성을 **스스로 관리**해야 한다(병렬성을 포기하든 `synchronized`를 이용하든..)
  
## 스트림 연산

* 연결할 수 있는 스트림 연산을 **중간 연산**이라고 하며, 스트림을 닫는 연산을 **최종 연산**이라고 한다.

### 중간 연산

* `filter, sorted` 같은 중간 연산은 다른 스트림을 반환한다.
* 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것, 즉 게으르다(lazy)는 것이다.
* 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문이다.

```java
List<String> names = menu.stream()
            .filter(dish -> {
                System.out.println("filtering: " + dish.getName());
                return dish.getCalories() > 300;
            })    // 루프 퓨전
            .map(dish -> {
                System.out.println("mapping: " + dish.getName());
                return dish.getName();
            })    // 루프 퓨전
            .limit(3)  // 쇼트서킷 
            .collect(toList());

        System.out.println("names = " + names);

        // 결과 
        filtering: pork
        mapping: pork
        filtering: beef
        mapping: beef
        filtering: chicken
        mapping: chicken
        names = [pork, beef, chicken]
```

* 스트림의 게으른 특성 덕분에 몇 가지 최적화 효과를 얻을 수 있었다.
* 첫째, 300칼로리가 넘는 요리는 여러 개지만 오직 처음 3개만 선택되었다. 이는 `limit` 연산 그리고 **쇼트서킷**이라 불리는 기법 덕분이다.
* 둘째, `filter, map`은 서로 다른 연산이지만 한 과정으로 병합되었다.
  * 이 기법을 **루프 퓨전**이라고 한다.

### 최종 연산

* 최종 연산은 스트림 파이프라인에서 결과를 도출한다.
* 보통 최종 연산에 의해 `List, Integer, void`등 스트림 이외의 결과가 반환된다.

### 스트림 이용하기

* 스트림 이용 과정은 세 가지로 요약 할 수 있다.

  1. 질의를 수행할 (컬렉션 같은) 데이터 소스
  2. 스트림 파이프라인을 구성할 중간 연산 연결
  3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

* 스트림 파이프라인은 빌더 패턴과 비슷하다.
  * 빌더 패턴에서 호출을 연결해서 설정을 만든다(스트림에서 중간 연산을 하는 것과 같다)
  * 준비된 설정에 `build` 메서드를 호출한다(스트림에서는 최종 연산에 해당)
