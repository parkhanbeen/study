# 함수형 관점으로 생각하기

### 공유된 가변 데이터

* 변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.
* 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.
* 어떤 자료구조도 바꾸지 않는 시스템이 있다고 가정하면 예상하지 못하게 자료구조의 값이 바뀔 일이 없으니 유지보수하기 쉬워진다.
* 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 `return`문을 통해서만 자신의 결과를 반환하는 메서드를 **순수** 메서드
 또는 **부작용 없는** 메서드라고 부른다. 구체적으로 말하는 부작용은 아래와 같다.
    * 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
    * 예외발생
    * 파일에 쓰기 등의 I/O 동작 수행
* 불변 객체를 이용해서 부작용을 없애는 방법도 있다.
  * 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다.
  * 따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀 수 없으므로 스레드 안전성을 제공한다.

### 선언형 프로그래밍

* `어떻게`에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다. 때로는 명령형 프로그래밍이라고 부르기도 한다.
```java
// '어떻게' 에 집중하는 형식
Transaction mostExpensive = transaction.get(0);
if (mostExpensive == null) {
    throw new IllegalArgumentException("Empty list of transactions");
}

for (Transaction t : transactions.subList(1, transactions.size())) {
    if (t.getValue() > mostExpensive.getValue()) {
        mostExpensive = t;
    }
}
```

* `어떻게`가 아닌 `무엇을`에 집중하는 방식도 있다. 
```java
Optional<Transaction> mostExpensive = transactions.stream()
    .max(comparing(Transaction::getValue));
```
* 이와 같은 구현 방식을 **내부 반복**이라고 한다. 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 큰 장점이다.
* 이처럼 `무엇을`에 집중하는 방식을 선언형 프로그래밍이라고 부른다.
* 선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다.
* 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.

### 왜 함수형 프로그래밍인가?

* 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 이전에 설명한 것처럼 부작용이 없는 계산을 지향한다.
* 선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.
* 람다 표현식을 이용해서 보여준 것처럼 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 
 많은 도움을 준다.
* 스트림으로는 여러 연산을 연결해서 복잡한 질의를 표현할 수 있다.
* 이러한 기능은 함수형 프로그래밍의 특징을 고스란히 보여준다.

## 함수형 프로그래밍이란 무엇인가?

* 함수형 프로그래밍은 말그대로 함수를 이용하는 프로그래밍이다.
* 그럼 함수란 무엇일까? 함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를
 반환하지만 **부작용이 없어야 한다.**
* 자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다. 특히 인수가 같다면 수학적 함수를 반복적으로
 호출했을 때 항상 같은 결과가 반환된다.
* **함수형**이라는 말은 `수학의 함수처럼 부작용이 없는`을 의미한다. 결과적으로 함수형 프로그래밍은 지금까지의 프로그래밍과는 사뭇 다른 모습일 것이다.
* 호출자에 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경쓸 필요가 없다.
* 결론적으로 `함수 그리고 if-then-else 등의 수학적 표현만 사용`하는 방식을 순수 함수형 프로그래밍이라고 하며 `시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용`
하는 방식을 함수형 프로그래밍이라 한다.

### 함수형 자바

* 실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다.
* 자바에서는 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 **함수형**을 달성할 수 있다.
* 함수나 메서드는 지역 변수만을 변경해야 **함수형**이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다.
* 즉, 객체의 모든 필드가 `final`이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.
* 예외적으로 메서 내에서 생성한 객체의 필드는 갱신할 수 있다는 사실을 살펴볼 것이다. 단, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하고 다음에
 메서드를 다시 호출한 결과에 영향을 미치지 않아야 한다.
* 함수형이라면 **함수나 메서드가 어떤 예외도 일으키지 않아야 한다.** 자바에서 예외를 일으키는 것은 자연스러운 방식이다 어떻게 해결 할 수 있을까?
* 바로 `Optional<t>`를 사용하면 문제를 해결할 수 있다. 호출자는 메서드 호출 결과로 빈 `Optional`이 반환되는지 확인해야 한다.
* 이는 상당히 귀찮은 작업처럼 보이겠지만 모든 코드가 `Optional`을 사용하도록 고쳐야 하는 것은 아니며 함수형 프로그래밍과 순수 함수형 프로그래밍의
 장단점을 실용적으로 고려해서 다른 컴포넌트에 영향을 미치지 않도록 지역적으로만 예외를 사용하는 방법도 고려할 수 있다.

### 참조 투명성

* `부작용을 감춰야 한다`라는 제약은 **참조 투명성** 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
* 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다. 따라서 `Random.nextInt`는 함수형이 될 수 없다.
* 참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 **기억화** 또는 **캐싱**을 통해 다시 계산하지 않고
 저장하는 최적화 기능도 제공한다.

### 객체지향 프로그래밍과 함수형 프로그래밍

* 프로그래밍 형식을 스펙트럼으로 표현하자면 스펙트럼의 한 쪽 끝에는 모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하고,
 관련 객체를 갱신하는 방식으로 동작하는 익스트림 객체지향 방식이 위치한다.
* 스펙트럼의 반대쪽 끝에는 참조적 투명성을 중요시하는, 즉 변화를 허용하지 않는 함수형 프로그래밍 형식이 위치한다. 실제로 자바 프로그래머는 이 두 가지 프로그래밍 형식을 혼합한다.

## 재귀와 반복

* 순수 함수형 프로그래밍 언어에서는 `while, for`같은 반복문을 포함하지 않는다. 이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다.
* 재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다. 자바 8 스트림으로 좀 더 단순하게 구현 가능하다.
* 효율성 측면에서 무조건 반복보다는 재귀가 좋다는 주장은 주의해야 한다. 일반적으로 반복 코드보다 재귀 코드가 더 비싸다. 재귀 함수를 호출할 때마다 호출 스택에 각 호출시
 생성되는 정보를 저장할 새로운 스택 프레임이 만들어진다. 즉, 재귀 팩토리얼의 입력값에 비례해서 메모리 사용량이 증가한다. 따라서 큰 입력값을 사용하면 `StackOverflowError`가 발생한다.
* 함수형 언어에서는 **꼬리 호출 최적화**라는 해결책을 제공한다.
```java
// 꼬리 재귀 팩토리얼
static long factorialTailRecursive(long n) {
        return factorialHelper(1, n);
    }

static long factorialHelper(long acc, long n) {
    return n == 1 ? acc : factorialHelper(acc * n, n - 1);
}
```
* `factorialHelper`에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리 재귀다.
* 중간 결과를 각각의 스택 프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.
* 안타깝게도 자바는 이와 같은 최적화를 제공하지 않는다. 그럼에도 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.
* 스칼라, 그루비 같은 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를 제공한다(속도의 손실 없이).
