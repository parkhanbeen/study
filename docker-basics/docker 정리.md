# 도커 정리

## 컨테이너

* 코드와 그 코드를 실행하는데 필요한 환경을 포함하는 격리된 박스
* 모든 컨테이너는 일반적으로 하나의 태스크에 집중함
    * 프론트엔드 서버 컨테이너, 웹서버 컨테이너, 데이터베이스 서버 컨테이너 다 따로 임
* 컨테이너는 일종의 무상태
    * 컨테이너가 종료될 때마다 데이터가 손실됨
    * 볼륨 제외

## 이미지

* 이미지로 컨테이너를 생성
* 이미지는 Dockerfile로 만들거나 Docker Hub에서 가져옴
* 하나의 동일한 이미지에서 다중 컨테이너를 실행할 수 있음
* 이미지는 공유 가능하며 읽기 전용임


## Volumes

* 도커에는 두 가지 외부 데이터 저장 메커니즘이 있음
    1. Volumes(볼륨)
    2. Bind Mounts(바인드 마운트)


* 볼륨은 호스트 머신의 폴더
* 컨테이너나 이미지에 있는 게 아님 즉, 호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나, 컨테이너로 매핑되는 것을 의미
* 볼륨은 도커가 인식하는 호스트 머신인 컴퓨터에 있는 폴더로서 도커 컨테이너 내부의 폴더에 매핑된다.
* 그리고 두 폴더의 변경 사항은 다른 폴더에 반영된다.
* 따라서 호스트 머신에 파일을 추가하면 컨테이너 내부에서 액세스할 수 있고 컨테이너가 매핑된 경로에 파일을 추가하면 컨테이너 외부, 즉 호스트 머신에서도 사용할 수 있다.

* 이러한 메커니즘은 볼륨을 통해 데이터를 유지할 수 있음

* VOLUME [ "/app/feedback" ] : 앞 경로는 컨테이너 내부 위치
* /app/feedback 경로는 호스트 머신의 어떤 폴더(도커에서 관리하는 폴더 우리는 모름...)에 매핑됨

* 볼륨을 매핑할 경우 더 구체적인 경로를 채택함
    * /app  /app/node_modules = /app/node_modules 채택

### 두 가지 타입의 볼륨

1. 익명(Anonymous)의 볼륨
    * 컨테이너가 존재하는 동안에만 실제로 존재함
    * 즉, 컨테이너를 종료하면 데이터가 사라짐
    * --rm 옵션으로 컨테이너 실행시 컨테이너가 제거되면 자동 종료
    * 만약 --rm 옵션 없이 컨테이너 실행시 컨테이너가 제거되더라도 볼륨은 계속 쌓임
        * 볼륨 제거 명령으로 정리해야됨
    * ex) docker run -v /app/data

2. 명명된(named) 볼륨
    * 컨테이너가 종료된 후에도 볼륨이 유지됨
    * 즉, 하드 드라이브의 폴더가 그대로 유지됨
    * 새 컨테이너가 시작되면 볼륨이 복구되고 폴더가 복구되어 해당 폴더에 저장된 모든 데이터를 계속 사용할 수 있음
    * 따라서 명명된 볼륨은 영구적이어야 하는 데이터나, 편집하거나 직접 볼 필요가 없는 중요한 데이터에 적합하다.
    * ex) -v {볼륨명}:{경로} : 호스팅 머신에 폴더를 만들어 컨텡이너 내부의 이 폴더에 연결하지만 이 볼륨은 우리가 선택한 이름으로 저장됨
    * ex) docker run -v data:/app/data

* **차이점**
    * 명명된 볼륨은 컨테이너가 종료될 때 도커에 의해 삭제되지 않는다. 익명 볼륨은 삭제됨
    * 컨테이너가 생성될 때마다 익명 볼륨은 다시 생성됨. 즉, 컨테이너가 제거되면 익명 볼륨은 의미 없음.
    * 익명 볼륨은 하나의 컨테이너와 연결되있음 하지만 명명된 볼륨은 하나의 컨테이너에만 연결되지는 않음


## Bind Mounts

* 호스트 머신 상에 매핑될 컨테이너의 경로 설정 가능
* 소스 코드를 실제로 스냅샷에서 복사하는 것이 아니라 바인딩 마운트에서 복사함
* 영구적이고 편집 가능한 데이터에 적합
* 이미지에는 영향을 주지않고, 컨테이너에만 영향을 줌

* 콜론 앞에 로컬 머신 경로가 붙으면 바인드 마운트가 됨
    * ex) -v feeback:/app/feedback -v "/Users/parkhanbin/git/study/docker-basics/data-volumes-01:/app"
    * ex) docker run -v /path/to/code:/app/code ...

* 콜론 앞에 경로가 아닌 것이 붙으면 볼륨 이름으로 취급되어 명명된 볼륨이 됨
    * -v feeback:/app/feedback


## 컨테이너 네트워크

* 모든 컨테이너가 서로 통신할 수 있는 네트워크를 형성
    * docker run --network my_network
* 다른 컨테이너를 호출 할 경우 컨테이너 이름으로 가능
    * 'mongodb://{컨테이너 이름}:27017/swfavorites'

### docker 네트워크 드라이버

* docker networks는 실제로 네트워크 동작에 영향을 미치는 다양한 종류의 '드라이버'를 지원
* 디폴트 드라이버는 **bridge** 드라이버이다.
    * 이 드라이버는 모듈에 나타난 동작을 제공(즉, 컨테이너가 동일한 네트워크에 있는 경우, 이름으로 서로를 찾을 수 있음)
* 드라이버는 네트워크 생성시 '--driver' 옵션을 추가하여 간단히 설정할 수 있음
* **bridge** 드라이버는 생략 가능


#### 드라이버 종류

* **host** : 스탠드얼론 컨테이너의 경우, 컨테이너와 호스트 시스템 간의 격리가 제거됨(즉, localhost를 네트워크로 공유함)

* **overlay** : 여러 Docker 데몬(즉, 서로 다른 머신에서 실행되는 Docker)이
서로 연결될 수 있음. 여러 컨테이너를 연결하는 구식의 / 거의 사용되지 않는 방법인 'Swarm' 모드에서만 작동

* **none** : 모든 네트워킹이 비활성화됨

* **서드파티 플러그인** : 모든 종류의 동작과 기능을 추가할 수 있는 타사 플러그인을 설치할 수 있다.


## 도커 컴포즈(Docker-Compose)

* 다중 컨테이너 설정을 더 쉽게 관리할 수 있는 도구
* 설정 프로세스를 자동화할 수 있음
* 도커 컴포즈는 커스텀 이미지를 위한 Dockerfile을 대체하지 않음
* 도커 컴포즈는 이미지나 컨테이너를 대체하지 않음
* 도커 컴포즈는 다수의 호스트에서 다중 컨테이너를 관리하는데는 적합하지 않음
* 하나의 동일한 호스트에서 다중 컨테이너를 관리하는데 좋음.

### 도커 컴포즈 파일

* 컴포즈 파일에 멀티 컨테이너 애플리케이션을 구성하는 핵심 구성 요소를 정의
* 도커 컴포즈를 이용하면 도커가 이 컴포즈 파일에 특정된 모든 서비스에 대해 새 환경을 자동으로 생성하고 모든 서비스를 즉시 그 네트워크에 추가함
* 즉, 하나의 동일한 컴포즈 파일에 정의된 모든 서비스는 이미 도커에 의해 생성된 동일한 네트워크의 일부가 됨
* 만약 네트워크를 등록하면 디폴트 네트워크 외에 지정된 네트워크에도 추가됨


* build : 빌드해야하는 Dockerfile을 찾을 곳을 지정
    * context : build 옵션 안에 중첩으로 사용 context 내에 Dockerfile을 보유하는 폴더의 경로를 특정함
        * context: ./backend
    * dockerfile : build 옵션 안에 중첩으로 사용 Dockerfile명이 다를 경우 지정
        * dockerfile: Dockerfile-dev


* depends_on : 의존성이 있는 컨테이너에 우선순위를 정하는 옵션
    * depends_on: - 서비스명

### 리눅스에 Docker Compose 설치하기

* 리눅스 시스템이서는 별도로 도커 컴포즈를 설치해야함

1. sudo curl -L "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

2. sudo chmod +x /usr/local/bin/docker-compose

3. sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

4. to verify: docker-compose --version

* 참조: https://docs.docker.com/compose/install/


## 유틸리티 컨테이너

* 특정 환경만 포함하는 컨테이너
    * ex) nodeJS 환경, PHP 환경 등등


## 개발환경과 프로덕션 환경

* 개발 환경에선 바인드 마운트를 많이 사용하지만 실제 프로덕션에서는 사용하지 않아야 한다.
    * 바운드 마운트 대신 복사(COPY)를 사용해야 한다.


## 쿠버네티스

* 오픈 소스 시스템
* 컨테이너 배포를 관리하고, 컨테이너를 오케스트레이션하기 위한 사실상의 표준이다.
* 실제로 도구는 아니지만 프레임워크, 개념 모음, 표준이라 할 수 있음
* 클라우드 프로바이더와 상관없이 컨테이너 오케스트레이션과 대규모 배포에 도움이 되는 도구이자 표준 모음이자 프레임워크

### 수동 배포의 문제점

* 자체적으로 관리하고 구성해야 함
* 인스턴스의 소프트웨어와 운영체제가 업데이트된 상태를 유지하도록 해야함
* 컨테이너가 충돌하거나, 다운될 수 있으며 새 컨테이너로 교체해야 함
* 컨테이너에 문제가 생길 때마다 모니터링을 이용해 수동으로 다시 컨테이너를 시작해야 함
* 트래픽 급증 시 더 많은 컨테이너 인스턴스가 필요함

### 왜 쿠버네티스 인가?

* 쿠버네티스로 배포하는 방식, 컨테이너 스케일링, 컨테이너가 실패할 경우의 모니터링하는 방법과 컨테이너를 교체하는 방법을 정의할 수 있음
* 클라우드 서비스와는 독립적으로 이 모든 것을 정의할 수 있는 방식을 가진다.
* 자동 배포, 스케일링, 로드 밸런싱, 일반적인 배포와 컨테이너 관리와 같은 태스크를 수행하는데 도움이 된다.


### 쿠버네티스 핵심 개념

* 포드(Pod) 
    * 쿠버네티스 세계의 가장 작은 단위
    * 단순히 컨테이너를 보유함(안에 컨테이너가 있음)
    * 다음 컨테이너를 실행할 책임이 있음

* 워커(worker) 노드 
    * 컨테이너를 실행하는 쿠버네티스 세계 내의 것
    * 머신, 가상 인스턴스라고 생각할 수 있다.
        * ex) 어딘가에서 실행 중인 ec2 인스턴스.
    * 특정 양의 cpu와 메모리가 있는 즉 컴퓨터이며 포드를 실행할 수 있다.
    * 동일한 워커 노드 중 하나에서 둘 이상의 포드을 실행할 수 있음.
    * 마스터 노드에서 관리됨.
    * 내부에 포드가 있음
    * 포드뿐 아니라 몇 가지 추가 소프트웨어 존재
        * Docker, Kubelet(실제로 마스터 노드와 통신), kube-proxy
        * kube-proxy : 들어오고 나가는 트래픽을 처리하는 책임을 가지며, 모든 것이 계획한대로 작동하도록 한다.

* 프록시
    * 워커 노드에서 워커 노드의 포드 네트워크 트래픽의 제어를 설정하는 또다른 도구
    * 즉, 프록시는 기본적으로 이러한 포드가 인터넷에 연결할 수 있는지의 여부와 이러한 포드 및 그 내부에서 실행되는 컨테이너를 외부 세계에서 어떻게 접근할 수 있는지를 제어함.
    * ex) 포드의 컨테이너에서 application 실행시 사용자의 외부 트래픽이 컨테이너에 도달하도록 프록시 구성

* 마스터 노드
    * 컨트롤 플레인에 의해 워커 노드와 상호작용한다.
    * 워커 노드와 상호 작용하여 제어하는 컨트롤 센터이다.
    * 워커 노드와 워커 노드상에서 실행중인 포드와 상호작용하는 책임을 가짐.

    * API 서버 : 워커 노드에서 실행되는 kubelet 서비스에 대한 카운터 포인트인 마스터 노드 머신에서 실행되는 간단한 서비스 즉, 워커와 마스터 노드 간의 통신을 위한 카운터 파트(대응자)

    * 스케줄러(Scheduler) : 새 포드가 생성되어야 하는 워커 노드를 선태갛는 일을 담당하는 스케줄러 즉, 실제로 워커 노드에 무엇을 알려야 하는지 API 서버에 알리는 역할

    * 큐브 컨트롤러 매니저(Kube-Controller-Manager) : 워커 노드 전체를 감시하고 제어하며 적당한 수의 포드를 가동 중에 있는지 확인하는 역할
        * 스케줄러 및 API 서버와 긴밀하게 연동됨.

    * 클라우드 컨트롤러 매니저(Cloud-Controller-Manager) : 큐브 컨트롤러 매니저와 동일한 작업을 수행하지만, 클라우드 프로바이더에 따라 다름(AWS 또는 MS Azure) 클라우드 프로바이더에게 무엇을 해야 하는지 알려줌


* 쿠버네티스로 작업할 때 일반적으로  하나 이상의 워커 노드가 필요하다.
    * 그렇지 않으면 포드와 컨테이너를 실행할 장소가 없기 때문이다.
* 중요한 사실은 쿠버네티스가 모든 것을 설치할 거란 생각이 들겠지만 그렇지않다.
* 쿠버네티스는 어떤 머신이나 가상 인스턴스도 생성하지 않으며, 소프트웨어를 설치하지 않는다.
* 애플리케이션에 필요한 리소스를 생성하려면, 직접 수행하거나 Kubermatic과 같은 도구 또는 EKS와 같은 관리형 서비스를 사용해야 한다.

### 쿠버네티스 핵심 용어 정리

#### 클러스터(Cluster)

* 클러스터는 노드 머신, 마스터, 워커 노드, 배포 혹은 원하는 최종 상태를 구성하는 모든 것의 컬랙션 세트

#### 노드(Nodes)

* 하나 또는 여러 개의 포드를 호스팅하는 특정 하드웨어 용량을 가지며 클러스터와 통신하거나, 클러스터 내에서 통신하는 물리적인 머신 또는 가상 머신

* 타입
    * 마스터 노드 : 모든 워커 노드를 걸쳐 포드를 관리하는 컨트롤 플레인을 가짐
    * 워커 노드 : 포드를 호스팅하는 실제 머신, 결국 앱 컨테이너와 이러한 컨테이너에 필요한 리소스를 실행


#### 포드(Pods)

* 애플리케이션 컨테이너와 요구 리소스가 포드라고 하는 유닛으로 결합됨을 의미
* 포드는 컨테이너를 감싼 껍질(shell) 같은 의미.
* 결국 컨테이너를 시작하여 그 특정 컨테이너를 관리.
* 포드 자체는 마스터 노드에 의해 관리.
* 포드가 생성되는 것은 포드에서 컨테이너를 실행하는 것과 같다.

#### 컨테이너(Containers)

* 일반 Docker 컨테이너
* 포드가 컨테이너를 실행한 뜻은 내부적으로 포드가 'docker run' 명령을 실행한다는 의미.


#### 서비스(Services)

* 고유한 포드 및 컨테이너에 독립적인 IP 주소를 가진 포드 그룹.
* 서비스는 프록시와 관련
* pod를 그룹화하고 공유 주소, 공유 IP 주소를 제공
* service를 사용하여 여러 pod를 해당 service로 이동하고, service에서 변경할 수 없는 IP 주소에 연결할 수 있도록 함.

#### Deployment

* Deployment는 쿠버네티스에서 널리 사용되는 오브젝트이다.
* ReplicaSet을 이용해 pod를 업데이트하고 관리하며 롤백(Rollback)을 하거나 특정 버전(revision)으로 돌아갈 수 있음.

### EKS vs ECS

* EKS(Elastic Kubernetes Service)
    * 쿠버네티스 배포를 위한 서비스
    * 쿠버네티스 구성을 사용하고 적용할 수 있도록 모든 것을 설정함.


* ECS(Elastic Container Service)
    * 컨테이너 배포를 위한 일반적인 서비스
    * 쿠버네티스와 관련 없음
    * 쿠버네티스와 사용하려면 모든 것을 직접 설정해야함
