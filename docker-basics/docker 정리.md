# 도커 정리

* 도커에는 두 가지 외부 데이터 저장 메커니즘이 있음
    1. Volumes(볼륨)
    2. Bind Mounts(바인드 마운트)

## Volumes

* 볼륨은 호스트 머신의 폴더
* 컨테이너나 이미지에 있는 게 아님 즉, 호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나, 컨테이너로 매핑되는 것을 의미
* 볼륨은 도커가 인식하는 호스트 머신인 컴퓨터에 있는 폴더로서 도커 컨테이너 내부의 폴더에 매핑된다.
* 그리고 두 폴더의 변경 사항은 다른 폴더에 반영된다.
* 따라서 호스트 머신에 파일을 추가하면 컨테이너 내부에서 액세스할 수 있고 컨테이너가 매핑된 경로에 파일을 추가하면 컨테이너 외부, 즉 호스트 머신에서도 사용할 수 있다.

* 이러한 메커니즘은 볼륨을 통해 데이터를 유지할 수 있음

* VOLUME [ "/app/feedback" ] : 앞 경로는 컨테이너 내부 위치
* /app/feedback 경로는 호스트 머신의 어떤 폴더(도커에서 관리하는 폴더 우리는 모름...)에 매핑됨

* 볼륨을 매핑할 경우 더 구체적인 경로를 채택함
    * /app  /app/node_modules = /app/node_modules 채택

### 두 가지 타입의 볼륨

1. 익명(Anonymous)의 볼륨
    * 컨테이너가 존재하는 동안에만 실제로 존재함
    * 즉, 컨테이너를 종료하면 데이터가 사라짐
    * --rm 옵션으로 컨테이너 실행시 컨테이너가 제거되면 자동 종료
    * 만약 --rm 옵션 없이 컨테이너 실행시 컨테이너가 제거되더라도 볼륨은 계속 쌓임
        * 볼륨 제거 명령으로 정리해야됨
    * ex) docker run -v /app/data

2. 명명된(named) 볼륨
    * 컨테이너가 종료된 후에도 볼륨이 유지됨
    * 즉, 하드 드라이브의 폴더가 그대로 유지됨
    * 새 컨테이너가 시작되면 볼륨이 복구되고 폴더가 복구되어 해당 폴더에 저장된 모든 데이터를 계속 사용할 수 있음
    * 따라서 명명된 볼륨은 영구적이어야 하는 데이터나, 편집하거나 직접 볼 필요가 없는 중요한 데이터에 적합하다.
    * ex) -v {볼륨명}:{경로} : 호스팅 머신에 폴더를 만들어 컨텡이너 내부의 이 폴더에 연결하지만 이 볼륨은 우리가 선택한 이름으로 저장됨
    * ex) docker run -v data:/app/data

* **차이점**
    * 명명된 볼륨은 컨테이너가 종료될 때 도커에 의해 삭제되지 않는다. 익명 볼륨은 삭제됨
    * 컨테이너가 생성될 때마다 익명 볼륨은 다시 생성됨. 즉, 컨테이너가 제거되면 익명 볼륨은 의미 없음.
    * 익명 볼륨은 하나의 컨테이너와 연결되있음 하지만 명명된 볼륨은 하나의 컨테이너에만 연결되지는 않음


## Bind Mounts

* 호스트 머신 상에 매핑될 컨테이너의 경로 설정 가능
* 소스 코드를 실제로 스냅샷에서 복사하는 것이 아니라 바인딩 마운트에서 복사함
* 영구적이고 편집 가능한 데이터에 적합
* 이미지에는 영향을 주지않고, 컨테이너에만 영향을 줌

* 콜론 앞에 로컬 머신 경로가 붙으면 바인드 마운트가 됨
    * ex) -v feeback:/app/feedback -v "/Users/parkhanbin/git/study/docker-basics/data-volumes-01:/app"
    * ex) docker run -v /path/to/code:/app/code ...

* 콜론 앞에 경로가 아닌 것이 붙으면 볼륨 이름으로 취급되어 명명된 볼륨이 됨
    * -v feeback:/app/feedback


## 컨테이너 네트워크

* 모든 컨테이너가 서로 통신할 수 있는 네트워크를 형성
    * docker run --network my_network
* 다른 컨테이너를 호출 할 경우 컨테이너 이름으로 가능
    * 'mongodb://{컨테이너 이름}:27017/swfavorites'

### docker 네트워크 드라이버

* docker networks는 실제로 네트워크 동작에 영향을 미치는 다양한 종류의 '드라이버'를 지원
* 디폴트 드라이버는 **bridge** 드라이버이다.
    * 이 드라이버는 모듈에 나타난 동작을 제공(즉, 컨테이너가 동일한 네트워크에 있는 경우, 이름으로 서로를 찾을 수 있음)
* 드라이버는 네트워크 생성시 '--driver' 옵션을 추가하여 간단히 설정할 수 있음
* **bridge** 드라이버는 생략 가능


#### 드라이버 종류

* **host** : 스탠드얼론 컨테이너의 경우, 컨테이너와 호스트 시스템 간의 격리가 제거됨(즉, localhost를 네트워크로 공유함)

* **overlay** : 여러 Docker 데몬(즉, 서로 다른 머신에서 실행되는 Docker)이
서로 연결될 수 있음. 여러 컨테이너를 연결하는 구식의 / 거의 사용되지 않는 방법인 'Swarm' 모드에서만 작동

* **none** : 모든 네트워킹이 비활성화됨

* **서드파티 플러그인** : 모든 종류의 동작과 기능을 추가할 수 있는 타사 플러그인을 설치할 수 있다.


## 도커 컴포즈(Docker-Compose)

* 다중 컨테이너 설정을 더 쉽게 관리할 수 있는 도구
* 설정 프로세스를 자동화할 수 있음
* 도커 컴포즈는 커스텀 이미지를 위한 Dockerfile을 대체하지 않음
* 도커 컴포즈는 이미지나 컨테이너를 대체하지 않음
* 도커 컴포즈는 다수의 호스트에서 다중 컨테이너를 관리하는데는 적합하지 않음
* 하나의 동일한 호스트에서 다중 컨테이너를 관리하는데 좋음.

### 도커 컴포즈 파일

* 컴포즈 파일에 멀티 컨테이너 애플리케이션을 구성하는 핵심 구성 요소를 정의
* 도커 컴포즈를 이용하면 도커가 이 컴포즈 파일에 특정된 모든 서비스에 대해 새 환경을 자동으로 생성하고 모든 서비스를 즉시 그 네트워크에 추가함
* 즉, 하나의 동일한 컴포즈 파일에 정의된 모든 서비스는 이미 도커에 의해 생성된 동일한 네트워크의 일부가 됨
* 만약 네트워크를 등록하면 디폴트 네트워크 외에 지정된 네트워크에도 추가됨


* build : 빌드해야하는 Dockerfile을 찾을 곳을 지정
    * context : build 옵션 안에 중첩으로 사용 context 내에 Dockerfile을 보유하는 폴더의 경로를 특정함
        * context: ./backend
    * dockerfile : build 옵션 안에 중첩으로 사용 Dockerfile명이 다를 경우 지정
        * dockerfile: Dockerfile-dev


* depends_on : 의존성이 있는 컨테이너에 우선순위를 정하는 옵션
    * depends_on: - 서비스명

### 리눅스에 Docker Compose 설치하기

* 리눅스 시스템이서는 별도로 도커 컴포즈를 설치해야함

1. sudo curl -L "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

2. sudo chmod +x /usr/local/bin/docker-compose

3. sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

4. to verify: docker-compose --version

* 참조: https://docs.docker.com/compose/install/


## 유틸리티 컨테이너

* 특정 환경만 포함하는 컨테이너
    * ex) nodeJS 환경, PHP 환경 등등