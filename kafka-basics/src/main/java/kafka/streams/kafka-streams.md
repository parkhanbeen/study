# 카프카 스트림즈

## 카프카 스트림즈란?

- 카프카 스트림즈는 토픽에 적재된 데이터를 상태기반 또는 비상태기반으로 실시간 변환하여 다른 토픽에 적재하는 라이브러리다.
- 카프카에서 공식적으로 지원하는 라이브러리로 매번 카프카 버전이 올르 때마다 스트림즈 자바 라이브러리도 같이 릴리즈된다.
- 그렇기 때문에 자바 기반 스트림즈 애플리케이션은 카프카 클러스터와 완벽하게 호환되면서 스트림 처리에 필요한 편리한 기능들을 제공한다.
- 장애가 발생하더라도 정확히 한번(exactly-once) 처리를 보장한다.
- 실시간 스트림 처리를 해야 하는 필요성이 있다면 스트림즈 애플리케이션으로 개발하는 것을 고려하는 것이 좋다.

## 구조
- 스트림즈 애플리케이션은 내부적으로 스레드를 1개 이상 생성할 수 있으며, 스레드는 1개 이상의 태스크를 가진다.
  - 스트림즈의 태스크(task)는 데이터 처리 최소 단위이다.
  - 만약 3개의 파티션으로 이루어진 토픽을 처리하는 스트림즈 애플리케이션을 실행하면 내부에 3개의 태스크가 생긴다.
  - 카프카 스트림즈는 컨슈머 스레드를 늘리는 방법과 동일하게 병렬처리를 위해 파티션과 스트림즈 스레드 또는 프로세스 개수를 늘림으로써
   처리량을 늘릴 수 있다.
- 스트림즈 구조는 토폴로지로 구성되었다.
  - 토폴로지란 2개 이상의 노드들과 선으로 이루어진 집합을 뜻한다.
  - 종류는 링형(ring), 트리형(tree), 성형(star) 등이 있는데 스트림즈는 트리 형태와 유사하다.
  - 스트림즈에서는 토폴로지를 이루는 노드를 하나의 `프로세서`라고 부르고 노드와 노드를 이은 선을 `스트림`이라고 부른다.
  - 스트림은 토픽의 데이터를 뜻하는데 프로듀서와 컨슈머에서 활용했던 레코드와 동일하다.
  - 프로세서에는 소스 프로세서, 스트림 프로세서, 싱크 프로세서 3가지가 있다.
    - 소스 프로세서: 하나 이상의 토픽의 데이터를 읽어들이는 프로세서
    - 스트림 프로세서: 데이터를 변환하는 프로세서
    - 싱크 프로세서: 데이터를 적재하는 프로세서
- 스트림즈 DSL과 프로세서 API 2가지 방법으로 개발 가능하다.
  - 스트림즈 DSL은 스트림즈 프로세싱에 필요한 대부분의 기능을 제공한다.
  - 프로세서 API는 스트림즈 DSL로 구현할 수 없는 복잡한 로직을 구현할 때 사용한다.

## 스트림즈 DSL
- 스트림즈 DSL에는 레코드의 흐름을 추상화한 3가지 개념인 `KStream`, `KTable`, `GlobalKTable`이 있다.

### KStream
- 레코드의 흐름을 표현한 것으로 메시지 키와 메시지 값으로 구성
- KStream으로 데이터를 조회하면 토픽에 존재하는(또는 KStream에 존재하는) 모든 레코드가 출력된다.
- KStream은 컨슈머로 토픽을 구독하는 것과 동일한 선상에서 사용하는 것이라고 볼 수 있다.

### KTable
- KTable은 KStream과 다르게 메시지 키를 기준으로 묶어서 사용한다.
- KStream은 토픽의 모든 레코들르 조회할 수 있지만 KTable은 유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용한다.
 그러므로 KTable로 데이터를 조회하면 메시지 키를 기준으로 가장 최신에 추가된 레코드의 데이터가 출력된다.

### GlobalKTable

- GlobalKTable은 KTable과 동일하게 메시지 키를 기준으로 묶어서 사용된다.
- 그러나 KTable로 선언된 토픽은 1개 파티션이 1개 태스크에 할당되어 사용되고, GlobalKTable로 선언된 토픽은 모든 파티션
 데이터가 각 태스크에 할당되어 사용된다는 차이점이 있다.
- KStream과 KTable 데이터 조인을 수행할 때 반드시 코파티셔닝(co-partitioning)이 되어야 한다.
  - 코파티셔닝이란 조인을 하는 2개 데이터의 파티션 개수가 동일하고 파티셔닝 전략을 동일하게 맞추는 작업이다.
  - 파티션 개수가 동일하고 파티션 전략이 같은 경우에는 동일한 메시지 키를 가진 데이터가 동일한 태스크에 들어가는 것을 보장한다.
  - 이를 통해 각 태스크는 KStream의 레코드와 KTable의 메시지 키가 동일한 경우 조인을 수행할 수 있다.
- 문제는 조인을 수행하려는 토픽들이 코파티셔닝되어 있음을 보장할 수 없다는 것이다.
  - KStream과 KTable로 사용하는 2개의 토픽이 파티션 개수가 다를 수 있고 파티션 전략이 다를 수 있다. 이런 경우에는 조인을 수행할 수 없다.
  - 코파티셔닝이 되지 않은 2개의 토픽을 조인하는 로직이 담긴 스트림즈 애플리케이션을 실행하면 `TopologyException`이 발생한다.
  - 코파티셔닝되어 있지 않으면 KStream 또는 KTable을 리파티셔닝(repartitioning)하는 과정을 거쳐야 한다.
  - 리파티셔닝은 새로운 토픽에 새로운 메시지 키를 가지도록 재배열하는 과정이다. 리파티셔닝 과정을 거쳐 KStream 토픽과 KTable 토픽
   코파티셔닝되도록 할 수 있다.
  - 리파티셔닝을 하는 과정은 토픽에 기존 데이터를 중복해서 생성할 뿐만 아니라 파티션을 재배열하기 위헤 프로세싱하는 과정도 거쳐야 한다.
- 코파티셔닝되지 않은 KStream과 KTable을 조인하고 싶다면 GlobalKTable을 선언하여 사용하면 된다.
- GlobalKTable로 정의된 데이터는 스트림즈 애플리케이션의 모든 태스크에 동일하게 공유되어 사용된다.
- 다만, GlobalKTable을 사용하만 각 태스크마다 GlobalKTable로 정의된 모든 데이터를 저장학 사용하기 때문에 스트림즈
 애플리케이션의 로컬 스트로지의 사용량이 증가하고 네트워크, 브로커에 부하가 생기므로 되도록이면 작은 용량의 데이터이 경우에만 사용하는 것이 좋다.
- 그러므로 많은 양의 데이터를 가진 토픽으로 조인할 경우에는 리파티셔닝을 통해 KTable을 사용할 것을 권장한다.

### 스트림즈 DSL 주요 옵션

- 스트림즈 DSL 애플리케이션을 실행할 때 설정해야 하는 필수 옵션과 선택 옵션이 있다.
- 필수 옵션은 사용자가 반드시 설정해야 하는 옵션이다. 선택 옵션은 사용자의 설정을 필수로 받지 않는다.

#### 필수 옵션
- **bootstrap.servers** : 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트 이름:포트를 1개 이상 작성한다.
 2개 이상 브로커 정보를 입력하여 일부 브로커에 이슈가 발생하더라도 접속하는 데에 이슈가 없도록 설정 가능하다.
- **application.id** : 스트림즈 애플리케이션을 구분하기 위한 고유한 아이디를 설정한다. 다른 로직을 가진 스트림즈 애플리케이션들은
 서로 다른 `application.id`를 가져야 한다.

#### 선택 옵션

- **default.key.serde** : 메시지 키의 직렬화/역직렬화 방식을 설정한다. 기본값은 `Serdes.ByteArray().getClass().getName()`이다.
- **default.value.serde** : 메시지 값의 직렬화/역직렬화 방식을 설정한다. 기본값은 `Serdes.ByteArray().getClass().getName()`이다.
- **num.stream.threads** : 스트림즈 애플리케이션을 실행할 스레드 개수를 설정한다. 기본값은 1이다.
- **state.dir** : rocksDB 저장소가 위치할 디렉토리를 지정한다. rocksDB는 페이스북이 개발한 고성능의 key-value db로서 카프카
 스트림즈가 상태기반 데이터 처리를 할 때 로컬 저장소로 사용한다. 기본값은 `/tmp/kafka-streams`이다. 스트림즈 애플리케이션을 상용에
 배포할때는 /tmp 디렉토리가 아닌 별도로 관리되는 디렉토리로 지정해야 안전하게 데이터가 저장된다.
