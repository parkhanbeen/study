# 변경 가능성을 최소화하라

* 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다.
* 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
* `String`, `BigInteger`, `BigDecimal`이 여기에 속한다.
* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

## 클래스를 불변으로 만드는 5가지 규칙

* **객체의 상태를 변경하는 메서드를 제공하지 않는다.**
* **클래스를 확장할 수 없도록한다.** 하위 클래스에서 부주의하게 혹은 나쁜의도로 객체의 상태를 변하게 만드는
  사태를 막아준다. 상속을 막는 대표적인 방법은 클래스를 `final`로 선언하는 것이지만, 다른 방법도 뒤에 살펴볼 것이다.
* **모든 필드를 `final`로 선언한다.** 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다.
  새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는 데도 필요하다.
* **모든 필드를 `private`으로 선언한다.** 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을
  막아준다. 기술적으로는 기본 타입 피륻나 불변 객체를 참조하는 필드를 `public final`로만 선언해도 불변 객체가 
  되지만, 이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권하지는 않는다.
* **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.** 클래스에 가변 객체를 참조하는 필드가 하나라도 
  있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다. 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게
  해서는 안되며, 접근자 메서드가 그 필드를 그대로 반환해서도 안된다.

```java
public class Account {
  private final String memo;
  private final int amount;

  public Board(String memo,
               int amount) {
    this.memo = memo;
    this.amount = amount;
  }
  
  public Account plus(int plusAmount) {
    return new Account(memo, amount + plusAmount);
  }

  // ..getter
}
```
* `plus`라는 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 
  함수형 프로그래밍 이라고 부른다.
* 이 방식으로 프로그래밍하면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 누릴 수 있다.

## 불변 객체를 사용해야 하는 이유

* **불변 객체는 단순하다.** 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
  * 모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히
    불변으로 남는다.
* **불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.** 여러 스레드가 동시에 사용해도 절대 훼손되지
  않는다.
  * 불변 객체는 안심하고 공유할 수 있기에 최대한 재활용하기를 권한다.
  * 가장 쉬운 재활용 방법은 `public static final`로 제공하는 것이다.
  > `public static final Complex ZERO = new Complex(0, 0);` <br>
  > `public static final Complex ONE = new Complex(1, 0);`
  * 정적 팩터리를 제공할수 있다. 정적 팩터리를 사용하면 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 
    가비지 컬렉션 비용이 줄어든다.
* 방어적 복사가 필요 없다. 아무리 복사해봐야 원본과 똑같으니 복사 자체가 의미없다.
  * 그러니 불변 클래스는 `clone`메서드나 복사 생성자를 제공하지 않는 게 좋다.
  * `String` 클래스의 복사 생성자는 이 사실을 잘 이해자이 못한 자바 초창기때 만들어진 것으로 되도록 사용하지 말아야 한다.
* **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.**
* **객체를 만들 때 다른 불변 객체들은 구성요소로 사용하면 이점이 많다.** 
  * 불변 객체는 맵의 키와 집합(Set)의 원소로 쓰기에 좋다. 맵이나 집합은 안에 담긴 값이 바뀌면 불변이 허물어지는데,
    불변 객체를 사용하면 그런 걱정은 하지 않아도 된다.
* **불변 객체는 그 자체로 실패 원자성을 제공한다.**
  * 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

## 불변 객체의 단점

* **값이 다르면 반드시 독립된 객체로 만들어야 한다.** 
  * 값의 가짓수가 많다면 이들을 모두 만드는데 큰 비용을 치러야 한다.
  * 해결 방법은 다단계 연산을 제공하는 것이다.
  * 클라이언트가 원하는 복잡한 연산드을 정확히 예측할 수 있다면 `package-private`의 가변 동반 클래스만으로 충분하다.
  * 대표적으로 `String`클래스의 가변 동반 클래스인 `StringBuilder`이다.

## 또 다른 불변 클래스 설계 방법

* 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 `final` 클래스로 선언하는 것이지만 더 유연한 방법이있다.
* 모든 생성자를 `private` 혹은 `package-private`으로 만들고 `public` 정적 팩터리를 제공하는 방법이다.

```java
public class Account {
  private final String memo;
  private final int amount;

  private Board(String memo,
               int amount) {
    this.memo = memo;
    this.amount = amount;
  }
  
  public static Account of(String memo, int amount) {
    return new Account(memo, amount);
  }
}
```
* 이 방식은 `public, protected` 생성자가 없으니 다른 패키지에서 이 클래스를 확장하는 게 불가능하다.

## 정리

* **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
* **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.**
  * **다른 합당한 이유가 없다면 모든 필드는 `private fianl`이어야 한다.**
* **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.**
  * 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 `public`으로 제공해서는 안된다.
