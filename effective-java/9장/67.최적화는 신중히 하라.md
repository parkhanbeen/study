# 최적화는 신중히 하라

성능 때문에 견고한 구조를 희생하지 말자. 

## 빠른 프로그램보다는 좋은 프로그램을 작성하라

* 좋은 프로그램이자만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.
* 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다.
* 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다([아이템 15](https://github.com/parkhanbeen/study/blob/master/effective-java/4%EC%9E%A5/15.%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%20%EB%A9%A4%EB%B2%84%EC%9D%98%20%EC%A0%91%EA%B7%BC%20%EA%B6%8C%ED%95%9C%EC%9D%84%20%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC.md)).
* 구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다.

## 성능을 제한하는 설계를 피하라

* 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
  * `API`, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 대표적
* 이런 설계 요소들은 완성후에는 변경하기 어렵거나 불가능할 수 있으며, 동시에 시스템 성능을 심각하게 제한할 수 있다.

## API를 설계할 때 성능에 주는 영향을 고려하라

* `public` 타입을 가변으로 만들면, 즉 내부 데이터를 변경할 수 있게 만들면 불필요한 방어적 복사를 수없이 유발할 수 있다([아이템 50](https://github.com/parkhanbeen/study/blob/master/effective-java/8%EC%9E%A5/50.%EC%A0%81%EC%8B%9C%EC%97%90%20%EB%B0%A9%EC%96%B4%EC%A0%81%20%EB%B3%B5%EC%82%AC%EB%B3%B8%EC%9D%84%20%EB%A7%8C%EB%93%A4%EB%9D%BC.md)).
  * 예) `java.awt.Component` 클래스의 `getSize()`
  * 해당 `API` 설계자는 이 메서드가 `Dimension` 인스턴스를 반환하도록 했다. 하지만 `Dimension`는 가변으로 `getSize()`를 호출 하는 모든 곳에서 
    인스턴스(방어적으로 복사) 를 새로 생성해야만 한다.
* 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 `public` 클래스는 상위 클래스에 영원히 종속되며 그 성능 제약까지도 물려받게 된다([아이템 18](https://github.com/parkhanbeen/study/blob/master/effective-java/4%EC%9E%A5/18.%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94%20%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC.md)).
* 인터페이스도 잇는데 굳이 구현 타입을 사용하는 것 역시 좋지 않다. 특정 구현체에 종속되게 하여, 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다([아이템 64](https://github.com/parkhanbeen/study/blob/master/effective-java/9%EC%9E%A5/64.%EA%B0%9D%EC%B2%B4%EB%8A%94%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%B4%20%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC.md)).

## 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다

* API를 왜곡하도록 만든 그 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수도 있지만, 왜곡된 API와 이를 지원하는 데 따르는 고통은
 영원히 계속될 것이다.

## 최적화 시도 전후로 성능을 측정하라

* 시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많고, 심지어 더 나빠지게 할 때도 있다.
* 주요 원인은 프로그램에서 시간을 잡아먹는 부분을 추측하기 어렵기 때문이다.
* 느릴 거라고 짐작한 부분이 사실은 성능에 별다른 영향을 주지 않는 곳이라면 시간만 허비한 꼴이 된다.
* 일반적으로 90%의 시간을 단 10%의 코드에서 사용한다는 사실을 기억해두자.
* 프로파일링 도구를 이용하여 최적화를 하도록 하자.
  * 이런 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공
  * 집중할 곳은 물론 알고리즘을 변경해야 한다는 사실을 알려주기도 한다.
  * 시스템 규모가 커질수록 프로파일러가 더 중요해진다.
* 최적화 시도 전후의 성능 측정은 c와 c++같은 전통적인 언에어서도 중요하지만, 자바 같은 성능 모델이 덜 정교한 언어에서 크게 중요하다.
  * 자바는 기본 연산에 드는 상대적인 비용을 덜 명확하게 정의하여 최적화로 인한 성능 변화를 일정하게 예측하기가 그만큼 더 어렵다.
  * 자바 성능 모델은 정교하지 않을 뿐더러 구현 시스템, 릴리스, 프로세서마다 차이가 있다.

## 정리

* 빠른 프로그램을 작성하려 안달하지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라오기 마련이다.
* 하지만 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두에 두어야 한다.
* 시스템 구현을 완료했다면 이제 성능을 측정해보자.
  * 충분히 빠르면 그것으로 끝이다.
  * 그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라.

