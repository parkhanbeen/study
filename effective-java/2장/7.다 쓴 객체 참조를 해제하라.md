# 다 쓴 객체 참조를 해제하라

* C나 C++ 언어는 프로그래머가 직접 메모리 관리를 해줘야 하지만 자바처럼 가비지 컬렉터를 갖춘 언어를
  사용하면 알아서 다 쓴 객체를 알아서 회수하여 메모리 관리를 따로 신경쓰지 않아도 될 것 같지만 사실을
  그렇지 않다.
* 아래는 책에 나와 있는 스택 구현 예제이다.

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
      if (size == 0) {
          throw new EmptyStackException();
      }
      return elements[--size];
    }

  /**
   * 원소를 위한 공간을 적어도 하나 이상 확보한다.
   * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
   */
  private void ensureCapacity() {
    if (elements.length == size) {
        elements = Arrays.copyOf(elements, 2 * size + 1);
    }
  }
}
```
* 해당 코드는 특별한 문제는 없어 보이지만 오래 실행하다 보면 점차 가비지 컬렉션 활동과 메모리 사용량이
  늘어나 결국 성능이 저하될 것이다.
* 문제는 스택이 커졋다가 줄어들었을 때 스택에서 꺼내진 객체들을 더이상 사용하지 않는다 해도 가비지
  컬렉터에서 회수하지 않는다.
* ```elements[--size]```만 해놓으면 실제 값은 삭제되지 않고 인덱스만 한칸씩 이동하는 것으로 
  메모리 누수가 발생하게된다.
* 가비지 컬렉션 언어에는 메모리 누수를 찾기 아주 까다롭다. 객체 참조 하나를 살려두면 그 객체 뿐만 아니라
  그 객체가 참조하는 모든 객체를 회수해가지 못한다.
* 해법은 해당 참조를 다 썻을 경우 ```null``` 처리를 하면된다.
* 아래 코드는 제대로 구현한 pop 메서드이다.

```java
public class Stack{
  // ...
  
  public Object pop() {
    if(size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;  // 다 쓴 참조 해제
    return result;
  }
}

```
* ```null```처리를 하면 이점도 있다. 만약 ```null``` 처리한 참조를 실수로 사용하려면 
  ```NullPointerException```을 던지며 종료된다. 미리 ```null``` 처리를 하지 않았더라면
  잘못된 일을 수행할 것이다.

## 모든 객체를 null 처리하는 것이 좋은 것일까?
* 그렇다고 모든 객체를 쓰지마자 ``null``처리할 필요는 없다.
* **객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.**
* 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(``scope``) 밖으로 밀어내는
  것이다. 그러면 자연스럽게 참조 해제가 일어날 것이다.

## Stack 클래스는 왜 메모리 누수에 취약한 걸까?
* ```stack```클래스는 자기 메모리를 직접관리하기 때문이다.
* ```stack```은 객체 자체가 아니라 객체 참조를 담는 elements 배열로 저장소 풀을 만들어 원소를 관리
  하여 배열 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않는다. 
* 문제는 가비지 컬렉터는 이사실을 알 수 없다. 가비지 컬렉터가 보기엔 비활성 영역에서 참조하는 객체도 유효한 객체이기 때문이다.
* 이러한 사실은 프로그래머만 알기 때문에 프로그래머는 비활성 여역이 되는 순간 ```null```처리를 하여
  객체가 더이상 쓰이지 않는다는 것을 가비지 컬렉터에게 알려야 한다.
* **일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야한다.**

## 캐시의 메모리 누수
* 객체 참조를 캐시에 넣고 나서 그 객체를 다 쓴 뒤로도 함참을 놔두는 일을 자주 접할 수 있다.
* 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 ```WeakHashMap```
  을 사용해 캐시를 만들어 사용하자. 
* 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다. 단, ```WeakHashMap```은 이러한 상황에서만 유용하다.
* 캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵다. 따라서, 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다.
* 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 한다.
* ```ScheduledThreadPoolExecutor``` 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다.
* ```LinkedHashMap```은 ```removeEldestEntry``` 메서드를 써서 후자의 방식으로 처리한다.
* 더 복잡한 캐시를 만들고 싶다면 ```java.lang.ref``` 패키지를 직접 활용해야 한다.

## 리스너(listener) 혹은 콜백(callback)의 메모리 누수

* 클라이언트가 콜백 등록만 하고 명확하게 해지하지 않을 경우 콜백은 계속 쌓여갈 것이다.
* 이럴 경우 콜백을 약한 참조(weak reference)로 저장할 경우 가비지 컬렉터가 즉시 수거해간다.
* 예를 들어 ```WeakHashMap```에 키로 저장하면 된다.

## 정리
* 메모리 누수는 겉으로 잘 드러나지 않아 수년간 잠복하는 사례도 있다. 이러한 누수는 철저한 코드리뷰
  나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다.
* 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.
