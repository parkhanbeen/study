# 디자인 패턴과 프레임워크

* 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.
* 디자인 패턴의 목적은 설계를 재사용하는 것이다. 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.


* **프레임워크**는 설계와 코드를 함께 재사용하기 위한 것이다.
* 프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
* 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 코드를 쉽고 빠르게 재사용할 수 있다.
* 프레임워크는 각 애플리케이션 요구에 따라 적절하게 커스터 마지이할 수 있는 확장 포인트를 제공한다.

* 결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

> #### 패턴의 핵심적인 특징
>
> * 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
> * 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
> * 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적으로 코드 작성을 돕는다.
> * 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

* 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 `아이디어`다.
* 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 `이름`이다.
* 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.

### 패턴 분류

* 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 **아키텍처 패턴(Architecture Pattern), 분석 패턴(Analysis Pattern),
 디자인 패턴(Design Pattern), 이디엄(Idiom)** 의 4가지로 분류하는 것이다.
* 가장 널리 알려진 것은 디자인 패턴으로 특정 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

#### 아키텍처 패턴
* 디자인 패턴 상위에는 소프트웨어의 전체적인 구조를 결정하는 **아키텍처 패턴**이 위치한다.
* 아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
* 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

#### 이디엄

* 디자인 패턴의 하위에 **이디엄**이 위치한다.
* 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포턴트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
* 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
  * ex) C++ **COUNT POINTER 이디엄**은 가상 머신이 참조되지 않는 객체를 자동으로 삭제하는 가비지 컬렉션 메커니즘을 가진 자바에서는 유용하지 않다.

#### 분석 패턴

* 다른 패턴은 주로 기술적인 문제를 해결하는데 초점을 맞추고 있다면 **분석 패턴**은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
* 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
* 분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.


### 패턴과 책임-주도 설계

* 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
  * **STRATEGY** 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임을 제공한다.
  * **BRIDGE** 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로
   분해함으로써 설계를 확장 가능하게 만든다.
  * **OBSERVER** 패턴은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임을 제공한다.
* 특정한 상황에 적용 가능한 패턴을 잘 알고 잇다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력
 관계를 빠르고 손쉽게 구성할 수 있다.

* 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.


### 캡슐화와 디자인 패턴

* 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
* 대부분의 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.
* 디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아니다.
* 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다. 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를
 이해하는 것이 더 중요하다.

### 패턴은 출발점이다

* 패턴은 설계의 목표가 되어서는 안된다.
* 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
* 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.


* 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
* 타당한 이유 없이 패턴을 적용하면 패턴에 익숙한 사람들의 경우에는 설계의 의도를 이해하지 못하게 되고, 패턴을 알지 못하는 사람들은 불필요하게
 복잡한 설계를 따라가느라 시간을 낭비하게 된다.
* 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
* 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다.
* 패턴을 적용할 때는 항상 설계를 좀 더 단순하고 명확하게 만들수 있는 방법이 없는지를 고민해야 한다. 또한 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야 한다.
* 만약 함께 작업하는 사람들이 패턴에 익숙하지 않다면 설계에 대한 지식과 더불어 패턴에 대한 지식도 함께 공유하는 것이 필요하다.


* 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 있다.
* 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정하라.
* 비록 패턴이 현재의 문제에 딱 들어맞지 않는다고 해도 참조할 수 있는 모법적인 역할과 책임의 집합을 알고 있는 것은 큰 도움이 될 것이다.


## 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

* 가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.
* **프레임워크**란 `추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계`,
 또는 `애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격을 의미한다.`
* 프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.
* 또한 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다.

### 상위 정책과 하위 정책으로 패키지 분리하기

* 객체지향 이전의 구조적인 설계와 같은 전통적인 소프트웨어 개발 방법의 경우 상위 레벨 모듈이 하위 레벨 모듈에, 그리고 상위 정책이 구체적인
 세부 사항에 의존하도록 소프트웨어를 구성한다.
* 하지만 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다.
* 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 한다.
* 하지만 상위 정책이 세부 사항에 의존하게 되면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 존재해야 하기 때문에 상위 정책의 재사용성이 낮아진다.
* 이 문제의 가장 좋은 해결 방법은 의존성 역정 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하게 만드는 것이다.


* 이를 위해서 변하는 것과 변하지 않는 것을 서로 분리해야 한다.
* 여기서 변하지 않는 것은 상위 정책 변하는 것은 세부 사항이다.
* 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록
 별도의 `배포 단위`로 분리해야 한다.
* 이를 위한 첫걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.
* 중요한 것은 패키지 사이의 의존성 방향이다. 의존성 역전 원리에 따라 추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로
 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.

### 제어 역전 원리

* 상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다.
* 의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.
* 의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.
* 시스템이 진화하는 방향에는 항상 의존성 역전 원리를 따르는 설계가 존재해야 한다.


* 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다.
* 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
* 전통적인 구조는 상위 정책의 코드가 하부의 구체적인 코드를 호출한다.
* 하지만 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다.
* 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
* 즉, 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다. 이를 **제어 역전 원리(Inversion of Control)**, 또는 **할리우드 원리(Hollywood)** 라고 한다.


* 협력을 제어하는 것은 프레임워크다.
* 우리는 프레임웤가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐이다.
