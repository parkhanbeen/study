# 의존성 관리하기

* 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서 변경을 방해하는 의존성은 제거하는데 있다.
* 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.

## 의존성 이해하기

### 변경과 의존성

* 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.
* 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
  * **실행 시점** : 의존하는 개체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
  * **구현 시점** : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

* 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

### 의존성 전이

* 의존성은 전이될 수 있다.
* 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.
* 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.
* 의존성은 정이될 수 있기 때문에 의존성의 종류를 **직접 의존성(direct dependency)** 과 **간접 의존성(indirect dependency)** 으로 나누기도 한다.
  * 직접 의존성은 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다. 이 경우 코드에 명시적으로 드러난다.
  * 간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다. 이 경우 코드안에 명시적으로 드러나지 않는다.

* 변경과 관련이 있는 어떤 것에도 의존성이라는 개념을 적용할 수 있다. 의존성의 대상은 객체일 수도 있고 모듈이나 더 큰 규모의 실행 시스템일 수도 있다.
* 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.

### 런타임 의존성과 컴파일타임 의존성

* 런타임은 애플리케이션 실행 시점을 가리킨다.
* 컴파일타임은 일반적으로 작성된 코드가 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 한다.
* 동적 타입 언어의 경우에는 컴파일타임이 존재하지 않기 때문에 컴파일타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다.
* 따라서 어딘가에서 컴파일타임이라는 용어를 보게 된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는
 것인지를 파악하는 것이 중요하다.

* 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.
* 반면, 코드 관점에서 주인공은 클래스다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

* 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
* 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안 된다.
* 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.
* 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다.
* 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.

### 컨텍스트 독립성

* 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.
* 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 **컨텍스트 독립성** 이라고 부른다.
* 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.
* 컨텍스트에 대한 정보가 적으면 적을수록 다양한 컨텍스트에서 재사용될 수 있기 때문이다. 결과적으로 설계는 더 유연해지고 변경에 탄력적으로 대응할 수 있게 될 것이다.

### 의존성 해결하기

* 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
* 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결** 이라고 부른다. 의존성을 해결하기 위해 일반적으로 세 가지 방법을 사용한다.
  1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  2. 객체 생성 후 setter 메서드를 통해 의존성 해결
     * setter 메서드를 이용한 방식은 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우 유용하다.
     * 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전가지 객체의 상태가 불완전할 수 있다.
     * 좋은 방법은 생성자와 setter 방식을 혼합하는 방법이다.
  3. 메서드 실행 시 인자를 이용해 의존성 해결
     * 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나,
      메서드가 실행될 때매다 의존 대상이 매번 달라져야 하는 경우에 유용하다.
     * 하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자나 setter 메서드를 이용해
      의존성을 지속적으로 유지하는 방식으로 변경하는 것이 좋다.


## 유연한 설계

### 의존성과 결합도

* 객체들이 협력하기 위해서는 서로 존재와 수행 가능한 책임을 알아야 한다. 이런 지식들이 객체 사이의 의존성을 낳는다.
* 따라서 모든 의존성이 나쁜 것은 아니다. 하지만 의존성이 과하면 문제가 될 수 있다.
* 어떤 의존성이 다향한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.
* 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.
* 다시 말해 컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
* 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것뿐이다.

* 바람직한 의존성과 바람직하지 못한 의존성을 가리키는 용어가 존재하는데 바로 **결합도**이다.
* 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 **느슨한 결합도(loose coupling)** 또는 **약한 결합도(weak coupling)**
 를 가진다고 말한다.
* 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 **단단한 결합도(tight coupling)** 또는 **강한 결합도(strong coupling)** 를 가진다고 말한다.

### 지식이 결합을 낳는다

* 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
* 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.
* 반대로 한 요소가 다른 요소에 대해 더 적은 정보를 알고 있을수록 두 요소는 약하게 결합된다.

* 더 많이 알수록 더 많이 결합된다. 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다.
* 기존 지식에 어울리지 않는 컨텍스트에서 클래스의 인스턴스를 사용하기 위해서 할 수 있는 유일한 방법은 클래스를 수정하는 것뿐이다.
* 결합도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 한다.
* 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.
* 가장 효과적인 방법은 **추상화**이다.

### 추상화에 의존하라

* 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
* 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.
* 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

* 일반적으로 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분하는 것이 유용하다. 목록에서 아래쪽으로 갈수록 클라이언트가 알아야 하는
 지식의 양이 적어지기 때문에 결합도가 느슨해진다.

  * **구체 클래스 의존성(concrete class dependency)**
  * **추상 클래스 의존성(abstract class dependency)**
  * **인터페이스 의존성(interface dependency)**

* 구체 클래스에 비해 추상 클래스는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다.
* 따라서 클라이언트가 알아야 하는 지식의 양이 더 적기 때문에 구체 클래스보다 추상 클래스에 의존하는 것이 결합도가 더 낮다.
* 하지만 추상 클래스의 클라이언트는 여전히 협력하는 대상이 속한 클래스 상속 계층이 무엇인지에 대해서는 알고 있어야 한다.


* 인터페이스에 의존하면 상속 계층을 모르더라도 협력이 가능해진다.
* 인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다.
* 이것은 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확장하는 것을 가능하게 한다.
* 여기서 중요한 것은 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다는 것이다.
* 결합도를 느슨하게 만드릭 위해서는 구체적인 클래스보다 추상 클래스에, 추상 클래스보다 인터페이스에 의존하도록 만드는 것이 더 효과적이다.
* 다시 말해 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다는 것이다. 이것이 핵심이다.


### 명시적인 의존성

* 모든 경우에 의존성은 명식적으로 퍼블릭 인터페이스에 노출된다. 이를 **명시적인 의존성(explicit dependency)** 이라고 부른다.
* 의존성이 퍼블릭 인터페이스에 표현되지 않는 경우를 **숨겨진 의존성(hidden dependency)** 라 부른다.
* 이는 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수밖에 없다.
* 더 커다란 문제는 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다는 것이다.
* 의존성을 명시적으로 드러내면 코드를 직접 수정해야 하는 위험을 피할 수 있다. 실행 컨텍스트에 적절한 의존성을 선택할 수 있기 때문이다.
* 의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라.

* 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.
* 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

* 클래스가 다른 클래스에 의존하는 것은 부끄러운 일이 아니다.
* 의존성은 다른 객체와의 협력을 가능하게 해주기 때문에 바람직한 것이다.
* 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것이다.
* 숨겨져 있는 의존성을 밝은 곳으로 드러내서 널리 알려라. 그렇게 하면 설계가 유연하고 재사용 가능해질 것이다.

### new는 해롭다

* 대부분의 언어에서는 클래스의 인스턴스를 생성할 수 있는 `new` 연산자를 제공한다. 하지만 안타깝게도 `new`를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.
* 결합도 측면에서 `new`가 해로운 이유는 크게 두 가지다.
  1. `new` 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 `new`를 사용하는 클라이언트는 추상화가 아닌
   구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
  2. `new` 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.
   따라서 `new`를 사용하려면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.

* 구체 클래스에 직접 의존하면 결합도가 높아진다는 사실을 기억하라.
* `new`는 클래스를 구체 클래스에 결합시키는 것만으로 끝나지 않는다. 협력할 클래스의 인스턴스를 생성하기 위해 어떤 인자들이 필요하고
 그 인자들을 어떤 순서로 사용해야 하는지에 대한 정보도 노출시킬뿐만 아니라 인자로 사용되는 구체 클래스에 대한 의존성을 추가한다.

* 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다.
* 필요한 인스턴스를 생성자의 인자로 전달받아 내부의 인스턴스 변수에 할당한다.
* 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다는 점을 기억하자.

### 가끔은 생성해도 무방하다

* 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다. 주로 협력하는 기본 객체를 설정하고 싶은 경우가 여기에 속한다.
* 만약 주로 협력하는 기본 객체를 설정하고 싶은 경우

```java
import java.time.Duration;

public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee) {
        this(title, runningTime, new AmountDisCountPolicy(...));
    }

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        ...
        this.discountPolicy = discountPolicy;
    }
}
```

* 기본 객체를 생성하는 생성자를 추가하고, 이 생성자에서 `DiscountPolicy`의 인스턴스를 인자로 받는 생성자를 체이닝하는 것이다.
* 클라이언트는 대부분의 경우 `AmountDisCountPolicy`의 인스턴스와 협력하게 하면서도 컨텍스트에 적절한 `DiscountPolicy`의 인스턴스로
 의존성을 교체할 수 있다.

* 이 방법은 메서드 오버로딩하는 경우에도 사용할 수 있다.

```java
public class Movie {
    public Money calculateMovieFee(Screening screening) {
        return calculateMovieFee(screening, new AmountDisCountPolicy(...));
    }

    public Money calculateMovieFee(Screening screening, DiscountPolicy discountPolicy) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

* 이러한 예는 설계가 트레이드오프 활동이라는 사실을 다시 한번 상기시킨다. 여기서 트레이드오프 대상은 결합도와 사용성이다.
* 구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로 코드를 작성할 수 있다.
* 그럼에도 가급적 구체 클래스에 대한 의존성을 제거할 수 있는 방법을 찾아보기 바란다.

### 표준 클래스에 대한 의존은 해롭지 않다

* 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.
* 따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.
* 자바라면 `JDK`에 포함된 표준 클래스가 이 부류에 속한다. 이런 클래스에 대해서는 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없다.

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();
    
    public void switchConditions(List<DiscountCondition> conditions) {
        this.conditions = conditions;
    }
}
```

* `ArrayList`의 코드가 수정될 확률은 0에 가깝기 때문에 인스턴스를 직접 생성하더라도 문제가 되지 않는다.
* 클래스를 직접 생성하더라도 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다.
* 의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다.

### 컨텍스트 확장하기

```java
import java.time.Duration;

public class Movie {
    public Movie(String title, Duration runningTime, Money fee) {
        this(title, runningTime, null);
    }

    public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        ...
        this.discountPolicy = discountPolicy;
    }

    public Money calculateMovieFee(Screening screening) {
        if (discountPolicy == null) {
            return fee;
        }
        
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

* 할인 해택을 제공하지 않을 경우 `null` 할당하고 `calculateMovieFee` 메서드 내부에서 `null` 여부를 체크한다.
* 해당 코드는 정상 동작하지만 예외 케이스를 처리하기 위해 내부 코드를 직접 수정해야 했다.
* 어떤 경우든 코드 내부를 직접 수정하는 것은 버그의 발생 가능성을 높이는 것이라는 점을 기억하라.
* 해결책은 할인 정책이 존재하지 않는다는 사실을 예외 케이스로 처리하지 말고 기존 협력 방식을 따르도록 만드는 것이다.

```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screenging screenging) {
        return Money.ZERO;
    }
}
```

* 만약 중복 적용이 가능한 할인 정책을 구현해야 한다면 `NoneDiscountPolicy`와 같은 방법을 사용해서 해결할 수 있다.

```java
import java.time.Duration;

public class OverlappedDiscountPolicy extends DiscountPolicy {
    private List<DiscountPolicy> discountPolicies = new ArrayList<>();

    public OverlappedDiscountPolicy(DiscountPolicy... discountPolicies) {
        this.discountPolicies = Array.asList(discountPolicies);
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        Money result = Money.ZERO;
        for (DiscountPolicy each : discountPolicies) {
            result = result.plus(each.calculateDiscountAmount(screening));
        }

        return result;
    }
}

// 클라이언트
class Client {
    public void enter() {
        Movie avatar = new Movie("아바타",
                Duration.ofMinutes(120),
                Money.wons(1000),
                new OverlappedDiscountPolicy(
                        new AmountDiscountPolicy(...),
                        new PercentDiscountPolicy(...)
                ));
    }
}
```

* 다양한 할인 정책이 필요한 컨텍스트에서 재사용할 수 있었던 이유는 코드를 직접 수정하지 않고도 협력 대상인 인스턴스를 교체할 수 있었기 때문이다.
* 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.
* 유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다.


* 유연하고 재사용 가능한 설계는 객체가 어떻게(how) 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 무엇(what)을 하지는지를 표현하는
 클래스들로 구성된다.
* 따라서 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악할 수 있다.
* 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다.
* 이런 설계를 창조한는 데 있어서의 핵심은 의존성을 관리하는 것이다.
