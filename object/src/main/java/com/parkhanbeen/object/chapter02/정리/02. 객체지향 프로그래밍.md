# 객체지향 프로그래밍

## 객체지향

* 클래스가 아닌 객체에 초점을 맞춰야 한다.
* 이를 위해서 프로그래밍하는 동안 두 가지에 집중해야 한다.

1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
   * 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
   * 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를
    먼저 결정해야 한다.
   * 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.

2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
   * 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
   * 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라보자.

## 도메인

* 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

## 클래스 구현

* 클래스를 구현하거나 다른 개발자에 의해 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다.
* 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
* 구분하는 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. 그리고 더 중요한 이유는 프로그래머에게 구현의 자유를 제공하기 때문이다.

## 자율적인 객체

1. 객체가 **상태(state)** 와 **행동(behavior)** 을 함께가지는 복잡한 존재이다.
2. 객체가 스스로 판단하고 행동하는 **자율적인 존재**라는 것이다.

* 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다.
* 이처럼 데이터와 기능을 함께 묶는 것을 **캡슐화**라고 한다.


* 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 **접근 제어(access control)** 메커니즘도 함께 제공한다.
* 많은 프로그래밍 언어들은 접근 제어를 위해 `public, protected, private`과 같은 **접근 수정자(access modifier)** 를 제공한다.
* 객체 내부에 대한 접근을 통제하는 이유는 자율적인 존재로 만들기 위해서이다.


* 캡슐화와 접근제어를 두 부분으로 나눈다.
  1. 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이스(public interface)** 
  2. 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현(implementation)** 이라 부른다.


## 프로그래머의 자유

* 프로그래머의 역할을 **클래스 작성자(class creator)** 와 **클라이언트 프로그래머(client programmer)** 로 구분하는 것이 유용하다.

* 클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다.
* 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.
* 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로
 변경할 수 있다. 이를 **구현 은닉(implementation)** 이라고 부른다.


## 협력

* 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청(request)** 할 수있다.
* 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)** 한다.
* 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)** 하는 것뿐이다.
* 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)** 했다고 한다.
* 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 부른다.

## 의존성

* 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
* 그리고 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.
* 한 가지 간과해서는 안 되는 사실은 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다.
* 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다.
* 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다.
* 이와 같은 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다.


* 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라.
* 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실도 기억하라.


## 상속

* 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
* 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다. 또한 상속을 이용하면 부모 클래스의 구현은
 공유하면서도 행동이 다른 자식 클랙스를 쉽게 추가할 수 있다.
* 이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍(programming by difference)**
 이라고 부른다.

* 상속을 통해 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문에 가치있는 것이다.

### 인터페이스

* 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하자.
* 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와
 동일한 타입으로 간주할 수 있다.

```java
// Movie 클래스의 calculateMovieFee 메서드
public Money calculateMovieFee(Screening screening) {
        return fee.minus(defaultDiscountPolicy.calculateDiscountAmount(screening));
    }
```

* `Movie`는 `DiscountPolicy` 인터페이스에 정의된 `calculateDiscountAmount` 메시지를 전송하고 있다.
* `Movie` 입장에서는 자신과 협력하는 객체가 어떤 클래스의 인스턴스인지 중요한게 아니라 `calculateDiscountAmount` 메시지를 수신할
 있다는 사실이 중요하다.
* 컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.
* 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅(upcasting)** 이라고 부른다.


## 다형성

* `Movie`는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스에 따라 달라진다.
* 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
* 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 따라서 다형적인 협력에 참여하는 객체들은 모두 
 같은 메시지를 이해할 수 있어야 한다. 다시 말해 인터페이스가 동일해야 한다는 것이다.

* 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.
* 다시 말해 메시지와 메서드를 실행 시점에 바인딩한다는 것이다. 이를 **지연 바인딩(lazy binding)** 또는 **동적 바인딩(dynamic binding)** 이라 한다.

### 구현 상속과 인터페이스 상속

* **구현 상속** : **서브클래싱(subclassing)** 이라 부르며 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
* **인터페이스 상속** : **서브타이핑(subtyping)** 이라 부르며 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 
 상속을 이용하는 것


* 상속은 구현 상속이 아닌 인터페이스 상속을 위해 사용해야 한다.
* 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.


## 추상화

* `Movie`와 `DiscountPolicy`는 수정하지 않고 `NoneDiscountPolicy`라는 새로운 클래스를 추가하는 것만으로 애플리케이션의 기능이 확장했다.
* 이처럼 추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다.
* 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문이다.
* 결론은 유연성이 필요한 곳에 추상화를 사용하라.

## 코드 재사용

### 합성(composition)

* 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.
* `Movie`가 `DiscountPolicy`의 코드를 재사용하는 방법이 바로 합성이다.

### 상속 단점

* 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
  1. 상속은 캡슐화를 위반한다.
     * 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
     * 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
     * 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.
  2. 설계를 유연하지 못하게 만든다.
     * 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
