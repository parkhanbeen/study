# 서브클래싱과 서브타이핑

* 상속의 용도는 타입 계층을 구현하는 것과 코드 재사용이다.
* 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화**이고 자식 클래스는 부모 클래스의 **특수화**이다.
* 코드 재사용은 간단한 선언으로 부모 클래스의 코드를 재사용할 수 있지만 부모 클래승와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.

## 타입

### 개념 관점의 타입

* 타입은 사물을 분류하기 위한 틀로 사용된다.
  * `자바, 루비, 자바스크립트, C`를 프로그밍 언어라는 타입으로 분류하고 있다.
* 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 **인스턴스(instance)** 라고 부른다.
  * `자바, 루비, 자바스크립트, C`를 프로그밍 언어의 인스턴스다.
* 일반적으로 타입의 인스턴스를 **객체**라고 부른다.
* 타입은 `심볼, 내연, 외연` 세 가지 요소로 구성된다.
  * **심볼**이란 타입에 이름을 붙인 것이다. 앞에서 `프로그래밍 언어`가 타입의 심볼에 해당한다.
  * **내연**이란 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. `프로그래밍 언어`의 정의인
   `컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합`이 바로 내연에 속한다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과
   행동의 집합이 내연을 구성한다.
  * **외연**이란 타입에 속하는 객체들의 집합이다. `프로그래밍 언어` 타입의 경우에는 `자바, 루비, 자바스크립트, C`가 속한 집합이 외연을 구성한다.

### 프로그래밍 언어 관점의 타입

* 프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.

  * **타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다**
    * 자바에서 `+` 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.
    * 하지만 `C++, C#`에서는 연산자 오버로딩을 통해 `+`연산자를 사용하는 것이 가능하다.
    
  * **타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다**
    * 자바에서 `a + b`라는 연산이 있을때 타입이 `int`라면 두 수를 더하지만 타입이 `String`이면 두 문자열을 하나의 문자열로 합칠 것이다.
    * 따라서 `a, b`에 부여된 타입이 `+` 연산자의 문맥을 정의한다.

* 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.


### 객체지향 패러다임 관점의 타입

* 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
* 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.


* 두 정의를 객체지향 패러다임의 관점에서 조합해보자
* 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다.
* 따라서 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다. 
* 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
* 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 이들은 서로 다른 타입으로 분류된다.
* 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.
* 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하라.


## 타입 계층

### 타입 사이의 포함관계

* 타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다.
* 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 **슈퍼타입(supertype)** 이라고 부르고 더 특수한 타입을 **서브타입(subtype)** 이라고 부른다.


* 내연의 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것이다.
* 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋(superset)이다.
* 반대로 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋(subset)이다.
* 따라서 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스이기도 하다.

* **슈퍼타입 특징**
  * 집합이 다른 집합의 모든 멤버를 포함한다.
  * 타입 정의가 다른 타입보다 좀 더 일반적이다.
* **서브타입 특징**
  * 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
  * 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

* 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
* 일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
* 특수한 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
* 따라서 퍼블릭 인터페이스의 관점에서 다음과 같이 정의한다.
  * **슈퍼타입**이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
  * **서브타입**이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.

## 서브클래싱과 서브타이핑

* 객체지향에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이고 타입 계층을 구현하는 일반적인 방법은 상속이다.
* 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 관계를 정의하는 것이다.
* 그렇다면 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 어떤 조건을 만족해야 할까?
* 서브타입의 퍼블릭 인터페이스가 슈퍼타입의 퍼블릭 인터페이스보다 더 특수하다는 것은 어떤 의미일까?

### 언제 상속을 사용해야 하는가?

* 올바른 상속을 위해 마틴 오더스키는 두 질문에 모두 '예'라고 답할 경우에만 상속을 사용하라 조언한다.
  1. **상속 관계가 is-a 관계를 모델링하는가?**
     * `자식 클래스는 부모 클래스다`라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
  2. **클라이언트 입장에서 부모 클래스의 탕입으로 자식 클래스를 사용해도 무방한가?**
     * 상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.
     * 이를 자식 클래스와 부모 클래스 사이의 **행동 호환성**이라고 부른다.

* 설계 관점에서 상속을 적용할지 여부를 결정하기 위해 첫 번째 질문보다는 두 번째 질문에 초점을 맞추는 것이 중요하다.


### is-a 관계

* `is-a`관계가 생각처럼 직관적이고 명쾌한 것은 아니다.

```java
public class Bird {
    public void fly() {
      ...
    }
}

public class Penguin extends Bird {
  ...

}
```

* 펭귄은 새지만 날 수 없는 새다. 하지만 코드에선 팽귄이 따라서 날 수 있다라고 표현하고 있다.


* 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
* 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.
* 따라서 슈퍼타입과 서브타입 관게에서는 `is-a`보다 행동 호환성이 더 중요하다.
* 어떤 두 대상을 언어적으로 `is-a`라고 표현할 수 있더라도 일단은 상속을 사용할 예비 후보 정도로만 생각하라.
  * 너무 성급하게 상속을 적용하려고 서두르지 마라.
  * 애플리케이션 안에서 두 가지 후보 개념이 어떤 방식으로 사용되고 협력하는지 살펴본 후에 상속의 적용 여부를 결정해도 늦지 않다.

### 행동 호환성

* 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.
* 행동의 호환 여부를 판단하는 기준은 **클라이언트의 관점**이다.
* 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
* 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.

### 클라이언트의 기대에 따라 계층 분리하기

* `펭귄과 새`의 상속관계 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것뿐이다.

```java
public class Bird {
  ...
}

public class FlyingBird extends Bird {
    public void fly() {
      ...
    }
}

public class Penguin extends Bird {
  ...
}
```

* 새에 날 수 없는 새와 날 수 있는 새의 두 부류가 존재하며, 펭귄은 날 수 없는 새에 속한다는 사실을 표현한다.
* 이 문제를 해결하는 다른 방법은 클라이언트에 따라 인터페이스를 분리하는 것이다.
* `fly` 오퍼레이션을 가진 인터페이스 `Flyer`와 `walk`오퍼레이션을 가진 `Walker` 인터페이스로 분리하는 것이다.
* 이제 펭귄과 새는 자신이 수행할 수 있는 인터페이스만 구현할 수 있다.

* 만약 펭귄이 새의 코드를 재사용해야 한다면 어떻게 해야 할까?
* 펭귄이 하나의 인터페이스만 구현하고 있기 때문에 문법상으로는 새를 상속받더라도 문제가 안 되겠지만 펭귄의 퍼블릭 인터페이스에 `fly`오퍼레이션이
 추가되기 때문에 이 방법은 사용할 수 없다.
* 더 좋은 방법은 합성을 사용하는 것이다. 물론 새의 퍼블릭 인터페이스를 통해 재사용 가능하다는 전제를 만족시켜야 한다.

* 클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다.
* 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경된다.
* 클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할 수 있게 된다.
* 이처럼 인터페이스를 클라리언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 **인터페이스 분리 원칙(Interface Segregation Principle, ISP)** 이라고 부른다.

### 서브클래싱과 서브타이핑

* **서브클래싱**
  * 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다. 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에
   자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수없다.
  * 서브클래싱을 **구현 상속** 또는 **클래스 상속**이라고 부르기도 한다.
* **서브타이핑**
  * 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다.
  * 서브타이핑에서는 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
  * 이때 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다.
  * 서브타이핑을 **인터페이스 상속**이라고 부르기도 한다.

* 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
* 즉, 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 **행동 호환성**을 만족시켜야 한다.
* 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성**을 포함한다.
* 행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야 할 지침이라고 할 수 있다. 이 지침은 리스코프 치환 원칙이라는 이름으로 정리되어 소개돼 왔다.

## 리스코프 치환 원칙

* 리스코프 치환 원칙을 한마디로 정의하면 `서브타입은 그것의 기반 타입에 대해 대체 가능해야한다`는 것으로 클라이언트가 `차이점을 인식하지 못한 채
 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다`는 것이다.
* 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야 한다.
* 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
* 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을때만 올바르다.
* 행동 호환성과 리스코프 치환 원칙에서 한 가지만 기억해야 한다면 대체 가능성을 결정하는 것은 클라이언트다.


* 클라이언트 관점에서 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 어휘적으로 `is-a`라고 말할 수 있다고 하더라도 
 그 관계를 `is-a`관계라고 할 수 없다.
* `is-a`는 클라이언트 관점에서 `is-a`일 때만 참이다.
* `is-a`관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.
* 일반적으로 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게
 되 롹률이 높다.

## 게약에 의한 설계와 서브타이핑

* 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 **계약에 의한 설계**라고 부른다.
* 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 **사전조건**과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는
 **사후조건**, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 **클래스 불변식** 세가지 요소로 구성된다.
* 계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.
